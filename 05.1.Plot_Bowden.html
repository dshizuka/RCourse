<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Dai Shizuka" />


<title>Worked Example: Plotting the change in butterfly size with climate change</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/sandstone.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 61px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 66px;
  margin-top: -66px;
}

.section h2 {
  padding-top: 66px;
  margin-top: -66px;
}
.section h3 {
  padding-top: 66px;
  margin-top: -66px;
}
.section h4 {
  padding-top: 66px;
  margin-top: -66px;
}
.section h5 {
  padding-top: 66px;
  margin-top: -66px;
}
.section h6 {
  padding-top: 66px;
  margin-top: -66px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->




<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Intro to R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="syllabus.html">Syllabus</a>
</li>
<li>
  <a href="modules.html">Modules</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Worked Example: Plotting the change in butterfly size with climate change</h1>
<h4 class="author"><em>Dai Shizuka</em></h4>
<h4 class="date"><em>updated 09/12/19</em></h4>

</div>


<hr />
<div id="things-you-will-learn-in-this-module" class="section level4">
<h4>Things you will learn in this module:</h4>
<ul>
<li><strong>More tricks to plotting</strong></li>
<li><strong>Using publicly available datasets</strong></li>
<li><strong>Implementing a simple statistical analysis (simple linear regression)</strong></li>
<li><strong>Creating a simple custom function</strong></li>
<li><strong>Repeating a routine with a custom function</strong></li>
</ul>
</div>
<div id="using-data-associated-with-published-papers" class="section level2">
<h2>5.1 Using data associated with published papers</h2>
<p>Today, we will learn a bit more about plots by trying to re-create a plot from a recent publication. I find playing with open-access data and re-creating analyses &amp; figures to be a very fruitful exercise because you get to learn codes, but you also get to really understand the studies much better.</p>
<p>For this exercise, I have chosen a paper by Bowden et al. (2015) in <em>Biology Letters</em>.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> This study used a 17-year dataset on wing lengths of two butterfly species in Greenland to show that both species follow the “temperature-size” rule, which posits that higher temperatures generally select for smaller adult body size.</p>
<div class="figure">
<img src="images/butterflies.png" alt="Boloria chariclea and Colias hecla" />
<p class="caption"><em>Boloria chariclea</em> and <em>Colias hecla</em></p>
</div>
<p>Aside from it being an interesting story, I chose this paper as an example for several reasons. First, the data are pretty straightforward–wing lengths of individuals, sex of individuals, and a few climatic data such as snowmelt day, average spring temperature and average spring/summer temperature of the previous year. More importantly, the authors made the raw data publicly available through the Dryad data repoistory (<a href="datadryad.org" class="uri">datadryad.org</a>). Here is the link to the raw data for this particular study: <a href="http://dx.doi.org/10.5061/dryad.43gt3" class="uri">http://dx.doi.org/10.5061/dryad.43gt3</a> (you can find this information under “Data accessibility”, right before References).</p>
<p>You can see that there is a link to an excel file (in .xlsx format) that contains the wing length data. In this case, there is no associated readme file (though it is encouraged by Dryad to include one), but the data are self-explanatory enough. <strong>Go ahead and download the data file and open it in Microsoft Excel.</strong></p>
<p>What you will see is a single worksheet with both species data. For each species, there are 9 columns: year, site, sex, WL (wing length), DOY (day of year of capture), snow (day of snowmelt), snow.1 (day of snowmelt in the previous year), mayjun (average May-June temperature), mayaug.1 (Average May-Aug temperature of previous year).</p>
<p>Now, since R will have a hard time reading this data, let’s manually create two separate data files and save them as .csv files. <strong>Follow these directions:</strong></p>
<ol style="list-style-type: decimal">
<li>Select and copy the 9 columns of data for <em>Boloria chariclea</em></li>
<li>Open a New Workbook (command-N) and paste the data</li>
<li>Save the file as “boloria.csv” in your folder for this week.</li>
<li>Do the same for Colias hecla, and save that file as “colias.csv”</li>
</ol>
<p>Now, let’s import these data to R:</p>
<pre class="r"><code># import the data
boloria = read.csv(&quot;data/boloria.csv&quot;)
colias = read.csv(&quot;data/colias.csv&quot;)
str(boloria)  #look at one of the dataframes</code></pre>
<pre><code>## &#39;data.frame&#39;:    3629 obs. of  9 variables:
##  $ year    : int  1996 1996 1996 1996 1996 1996 1996 1996 1996 1996 ...
##  $ site    : int  2 2 2 2 2 2 2 2 2 2 ...
##  $ sex     : Factor w/ 2 levels &quot;f&quot;,&quot;m&quot;: 2 2 2 1 2 2 2 1 1 1 ...
##  $ WL      : num  17.6 17.9 17.3 19.3 18.8 ...
##  $ DOY     : int  189 189 189 196 196 196 210 210 217 217 ...
##  $ snow    : num  159 159 159 159 159 ...
##  $ snow.1  : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ mayjun  : num  -1.76 -1.76 -1.76 -1.76 -1.76 ...
##  $ mayaug.1: num  NA NA NA NA NA NA NA NA NA NA ...</code></pre>
<p>Now, we can proceed with our exercise.</p>
</div>
<div id="recreating-figure-1-scatterplot-with-fit-line" class="section level2">
<h2>5.2 Recreating Figure 1: Scatterplot with fit line</h2>
<p>The first thing we will try is to re-create Figure 1, which has three panels and shows how the snowmelt dat, average May-June temperature, and average May-August temperature (of the previous year) has changed across the study period. They present this as a scatterplot and a simple linear regression fit line.</p>
<div class="figure">
<img src="images/5.1_Fig1.png" alt="Figure 1 from Bowden et al. (2015): (a) Timing of snowmelt (F_{1,16} = 8.92, estimate = -1.05, R^2_{Adj} = 0.32, p &lt; 0.008), (b) May-June_t temperature (F_{1,16} = 10.87, estimate = 0.11, R^2_{Adj} = 0.37, p &lt; 0.005) and (c) May-June_{t-1} temperature (F_{1,16} = 22.52, estimate = 0.11, R^2_{Adj} = 0.56, p &lt; 0.001) from 1996-2013 at Zackenberg, Greenland" />
<p class="caption">Figure 1 from Bowden et al. (2015): (a) Timing of snowmelt (<span class="math inline">\(F_{1,16}\)</span> = 8.92, estimate = -1.05, <span class="math inline">\(R^2_{Adj}\)</span> = 0.32, <span class="math inline">\(p\)</span> &lt; 0.008), (b) <span class="math inline">\(May-June_t\)</span> temperature (<span class="math inline">\(F_{1,16}\)</span> = 10.87, estimate = 0.11, <span class="math inline">\(R^2_{Adj}\)</span> = 0.37, <span class="math inline">\(p\)</span> &lt; 0.005) and (c) <span class="math inline">\(May-June_{t-1}\)</span> temperature (<span class="math inline">\(F_{1,16}\)</span> = 22.52, estimate = 0.11, <span class="math inline">\(R^2_{Adj}\)</span> = 0.56, <span class="math inline">\(p\)</span> &lt; 0.001) from 1996-2013 at Zackenberg, Greenland</p>
</div>
<p><strong>Alright, let’s try to re-create this!</strong></p>
<div id="multi-panel-scatterplot" class="section level3">
<h3>5.2.1 Multi-panel scatterplot</h3>
<p>First thing we’ll do is re-create the scatterplot of Figure 1a: The date of snowmelt by year. Close reading of the supplemental methods section tells us that this is the first day of the year that less than 50% of the site was covered in snow.</p>
<p>The dataset we have downloaded is organized by individual butterflies that were caught during the study. However, the snowmelt and temperature information are the same for all rows for a given year (and this info is the same for both species of butterfly). So we can actually extract all of the information we need for this figure from this data. All we need to do is to summarize the snowmelt and temperature data for each year. To do this, we will use the <code>aggregate()</code> function. To review, we can use this function to just get the day of snowmelt for each year:</p>
<pre class="r"><code>snow.years = aggregate(boloria$snow, list(boloria$year), mean)  #take mean of snowmelt day for each year. Since all values for a given year is the same, taking the mean just returns that value
head(snow.years)  #just show the first 6 lines. </code></pre>
<pre><code>##   Group.1      x
## 1    1996 158.80
## 2    1997 159.00
## 3    1998 161.00
## 4    1999 166.67
## 5    2000 154.83
## 6    2001 158.50</code></pre>
<p>So this results in a dataframe with two columns: the first column is the year and the second column is the snowmelt day.</p>
<p>Let’s expand on this and create a single dataframe that has all of the information we need: year, snowmelt day, average May-June temperature of that year, and average May-August temperature of the previous year. We can do this by using the <code>aggregate()</code> function with the first argument as the columns of the original dataset that we want to extract:</p>
<pre class="r"><code>year.dat = aggregate(boloria[c(&quot;snow&quot;, &quot;mayjun&quot;, &quot;mayaug.1&quot;)], 
    list(year = boloria$year), mean)
# note:&#39;year=boloria$year&#39; inside the list() function just
# allows us to name the output column when creating it.
head(year.dat)  #look at first 6 lines</code></pre>
<pre><code>##   year   snow  mayjun  mayaug.1
## 1 1996 158.80 -1.7558        NA
## 2 1997 159.00 -2.2195 1.6278379
## 3 1998 161.00 -2.8707 1.1259500
## 4 1999 166.67 -1.3216 0.8935792
## 5 2000 154.83 -1.8207 1.6399051
## 6 2001 158.50 -2.2239 1.4483740</code></pre>
<p>Great! So we can now just create the scatter plot for Figure 1a:</p>
<pre class="r"><code>plot(year.dat$year, year.dat$snow, pch = 19, xlab = &quot;year&quot;, ylab = &quot;snowmelt (DOY)&quot;, 
    las = 1, ylim = c(130, 170), yaxp = c(130, 170, 4), xlim = c(1995, 
        2015), xaxp = c(1995, 2015, 4))</code></pre>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-5-1.png" width="288" /></p>
<p>In fact, it is pretty straightforward to re-create all 3 panels in Figure 1. We just need to use the <code>par()</code> function to create</p>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-6-1.png" width="192" /></p>
<p>We won’t worry about the minutiae of the axis labels. Let’s move on to the regression line.</p>
<hr />
</div>
<div id="simple-linear-regression-using-lm" class="section level3">
<h3>5.2.2 Simple linear regression using <code>lm()</code></h3>
<p>The first thing we need to learn is the function for conducting the simplest form of a linear regression. So, what is a linear regression? A lot of people think that linear regression (or <em>linear model</em>) means that the relationship between two variables is defined by a straight line. This is not quite correct. More properly, linear model is a class of statistic models in which the value of interest is described by a linear combination of a series of parameters (regression slopes and intercept). This can actually include curvilinear relationships between the dependent and independent variables.</p>
<p>My aim here is not to provide a thorough lesson on statistics. For that, I suggest you take a proper statistics class or consult a statistics textbook.</p>
<p>Here, we will just tackle the problem of fitting a <strong><em>simple linear regression</em></strong> with one continuous dependent variable (<span class="math inline">\(y\)</span>) and one continuous independent variable (<span class="math inline">\(x\)</span>). Thus, we want to fit the linear function <span class="math display">\[y=a+bx\]</span> where <span class="math inline">\(a\)</span> is the intercept and <span class="math inline">\(b\)</span> is the slope of the line.</p>
<p>To fit this model, we use a model formula syntax inside the appropriate statistical function. In this case, the appropriate formula is<br />
<code>y~x</code></p>
<p>Notice that we replace the equal sign (=) with a tilde (~) and remove the paramters (<span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>). All R needs to understand our statistical model is the dependent variable(s) (<span class="math inline">\(y\)</span> in this case) and the independent variable(s) (<span class="math inline">\(x\)</span> in this case). We will address the formula syntax for more complex statistical models later.</p>
<p>Now, let’s use the simple linear regression to ask the question: what is the relationship between snowmelt date (dependent variable) and year (independent variable).<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> To do this, we will create an object using the <code>lm()</code> function and then see what the resulting object looks like:</p>
<pre class="r"><code>fit.snow = lm(snow ~ year, data = year.dat)
class(fit.snow)</code></pre>
<pre><code>## [1] &quot;lm&quot;</code></pre>
<p>So, you can see that the <code>lm()</code> function creates an ‘lm object’. The <code>fit.snow</code> object actually contains much more information. To see all of the components of this model object, see:</p>
<pre class="r"><code>str(fit.snow)  #output not shown</code></pre>
<p>This will yield a very long output that details all of the components of the model fitting results that we might want. Ok, so how do we extract the information we want from this statistical analysis? One convenient function is the <code>summary()</code> function:</p>
<pre class="r"><code>summary(fit.snow)</code></pre>
<p>So this gives us a good overview of the statistical outpu, but it gives us a lot of information, and you have to know what to look for. Let’s look at these values closely:</p>
<div class="figure">
<img src="images/5.1_summary_fit.snow.png" alt="Output of summary(fit.snow)" />
<p class="caption">Output of <code>summary(fit.snow)</code></p>
</div>
<p>The values reported in the caption of Figure 1 of the paper are in the rectangles:</p>
<ul>
<li>“Estimate” for the independent variable (year) is the <strong>slope parameter <span class="math inline">\(b\)</span></strong> (red rectangle). The intercept parameter <span class="math inline">\(a\)</span> is above that.</li>
<li><strong>F-statistic</strong> (green rectangle): Ratio of Mean of squares. Compares the amount of variation explained by the regression model and the “left-over variation” (residual sum of squares). The associated <strong>degrees of freedom (DF)</strong>–i.e., how many independent observations we have of a given variable that can be used to estimate a statistical parameter–are the “regression degrees of freedom”&quot; (# parameters -1) and the “residual degrees of freedom” (sample size - # of parmeters - 1)</li>
<li><strong>P-value</strong>: Calculated by comparing the F-ratio with expected distribution of this value.</li>
</ul>
<p><strong><em>NOTE:</em></strong> There are also t-statistics and P-values associated with each parameter (in purple circle). These are P-values associated with the null hypotheses that the intercept and slope are equal to 0. This is different than the P-value for the test for the fit of the linear regression model to the data. Thus, those circled values are NOT relevant for us right now.</p>
<p><strong>Now compare these values in the rectangles to the values presented in the figure captions to Figure 1 in the paper. Do you notice that they are slightly different? Can you figure out why they are slightly different?<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></strong></p>
<hr />
</div>
<div id="group-exercise" class="section level3">
<h3>Group Exercise:</h3>
<p>Conduct linear regression analyses for the following relationships:</p>
<ul>
<li>May-June temperature across years</li>
<li>May-August temperature from the previous year, across years.</li>
</ul>
<hr />
</div>
<div id="fit-line-using-abline" class="section level3">
<h3>5.2.3 Fit line using <code>abline()</code></h3>
<p>Now, let’s use the output of the linear regression model to plot a ‘best fit’ regression line on the scatterplot of data. There are at least two ways to do this. We will start with the simpler method: using the <code>abline()</code> function. This function can take the output of the <code>lm()</code> function directly and plot a regression fit line. This function needs to be called after the plot already exists.</p>
<pre class="r"><code>plot(year.dat$year, year.dat$snow, pch = 19, xlab = &quot;year&quot;, ylab = &quot;snowmelt (DOY)&quot;, 
    las = 1, ylim = c(130, 170), yaxp = c(130, 170, 4), xlim = c(1995, 
        2015), xaxp = c(1995, 2015, 4))
abline(fit.snow)</code></pre>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-11-1.png" width="336" /></p>
<p>What the <code>abline()</code> function essentially does is extract the intercept and slope parameters from the regression fit and draws that line. This is very convenient and generally gives us what we want. However, the problem with this method is that the line is not confined to the dataset (i.e., the line extrapolates beyond the data we have).</p>
<hr />
</div>
<div id="fit-line-using-predict" class="section level3">
<h3>5.2.4 Fit line using <code>predict()</code></h3>
<p>To draw a proper regression fit line, we want to confine the line to the range of points on the x-axis. To do this, there are three steps:</p>
<ol style="list-style-type: decimal">
<li>Decide the range of x-values that we want to plot</li>
<li>Generate predicted y-values based on the model fit for that range of x-values</li>
<li>Use the <code>line()</code> function to plot this “predicted” relationship (i.e., the best-fit line)</li>
</ol>
<p>For this example, step 1 is easy: we want to fit a line to the data ranging from 1996 to 2013. To accomplish step 2, we will use the <code>predict()</code> function. This function allows us to take any statistical model, feed it a range of x-values and get the y-values based on the parameters. The syntax of the function is: <code>predict(model_object, list(dependent_variable_name=range_of_x_values))</code><br />
So, to get the predicted y-values based on the years 1996-2013:</p>
<pre class="r"><code>xv = seq(1996, 2013, 1)  #The range of x-values that I want to fit the line to
predict.snow = predict(fit.snow, list(year = xv))  #predicted values that correspond to those x-values.
predict.snow</code></pre>
<pre><code>##        1        2        3        4        5        6        7        8 
## 162.7781 161.7089 160.6397 159.5705 158.5013 157.4321 156.3629 155.2938 
##        9       10       11       12       13       14       15       16 
## 154.2246 153.1554 152.0862 151.0170 149.9478 148.8786 147.8094 146.7402 
##       17       18 
## 145.6710 144.6018</code></pre>
<p>We can then use these values to draw a fit line on the plot:</p>
<pre class="r"><code>plot(year.dat$year, year.dat$snow, pch = 19, xlab = &quot;year&quot;, ylab = &quot;snowmelt (DOY)&quot;, 
    las = 1, ylim = c(130, 170), yaxp = c(130, 170, 4), xlim = c(1995, 
        2015), xaxp = c(1995, 2015, 4))
lines(xv, predict.snow)</code></pre>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-14-1.png" width="336" /></p>
<p><strong>Note</strong> Since we are fitting a simple straight line, we technically only need two x-values to accomplish this. So, the following codes would produce the same figure (output not shown).</p>
<pre class="r"><code>xv2 = c(1996, 2013)  #just the minimum and maximum values on the x-axis
predict.snow2 = predict(fit.snow, list(year = xv))
plot(year.dat$year, year.dat$snow, pch = 19, xlab = &quot;year&quot;, ylab = &quot;snowmelt (DOY)&quot;, 
    las = 1, ylim = c(130, 170), yaxp = c(130, 170, 4), xlim = c(1995, 
        2015), xaxp = c(1995, 2015, 4))
lines(xv, predict.snow)</code></pre>
<p>However, if you were to fit a more complext model fit, you would want to predict many points along the spectrum of x-values. We may eventually tackle this type of problem later in the course.</p>
<p>Ok, now let’s plot all three panels of Figure 1 in one fell swoop:</p>
<pre class="r"><code>### Regression models
fit.snow = lm(snow ~ year, data = year.dat)  #regression fit for snowmelt date
fit.mayjun = lm(mayjun ~ year, data = year.dat)  #regression fit for May-June temp
fit.mayaug.1 = lm(mayaug.1 ~ year, data = year.dat)  #regression fit for May-Aug temp from last year.

# set up fit line x- and y-values
xv = seq(1996, 2013, 1)
predict.snow = predict(fit.snow, list(year = xv))
predict.mayjun = predict(fit.mayjun, list(year = xv))
predict.mayaug.1 = predict(fit.mayaug.1, list(year = xv))

# plot multi-panel figure
par(mfrow = c(3, 1), mar = c(4, 4, 1, 2))

plot(year.dat$year, year.dat$snow, pch = 19, xlab = &quot;year&quot;, ylab = &quot;snowmelt (DOY)&quot;, 
    las = 1)
lines(xv, predict.snow)

plot(year.dat$year, year.dat$mayjun, pch = 19, xlab = &quot;year&quot;, 
    ylab = &quot;Average Temperature&quot;, las = 1)
lines(xv, predict.mayjun)

plot(year.dat$year, year.dat$mayaug.1, pch = 19, xlab = &quot;year&quot;, 
    ylab = &quot;Average Temperature Last Year&quot;, las = 1)
lines(xv, predict.mayaug.1)</code></pre>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-16-1.png" width="240" /></p>
<p>We can add a bunch of arguments to the plotting function to really make it close to the Figure if we want to make it a real publication-quality figure. (I won’t walk through all of the arguments)</p>
<pre class="r"><code>par(mfrow = c(3, 1), xpd = T)
par(mar = c(4, 5, 1, 2))
plot(year.dat$year, year.dat$snow, pch = 19, ylab = &quot;snowmelt (DOY)&quot;, 
    las = 1, ylim = c(130, 170), yaxp = c(130, 170, 4), xlim = c(1995, 
        2015), xaxp = c(1995, 2015, 4), xlab = &quot;&quot;, xaxt = &quot;n&quot;, 
    cex = 1.5)
axis(side = 1, labels = FALSE)
lines(xv, predict.snow)
text(1990, 170, substitute(italic(&quot;(a)&quot;)))
par(mar = c(4, 5, 1, 2))
plot(year.dat$year, year.dat$mayjun, pch = 19, ylab = expression(paste(&quot;Average Temperature&quot;[&quot;t&quot;], 
    &quot; &quot;, (~degree * C))), las = 1, ylim = c(-3, 0.5), yaxp = c(-3, 
    0, 3), xlim = c(1995, 2015), xaxp = c(1995, 2015, 4), xlab = &quot;&quot;, 
    xaxt = &quot;n&quot;, cex = 1.5)
axis(side = 1, labels = FALSE)
lines(xv, predict.mayjun)
text(1990, 0.5, substitute(italic(&quot;(b)&quot;)))
par(mar = c(4, 5, 1, 2))
plot(year.dat$year, year.dat$mayaug.1, pch = 19, xlab = &quot;year&quot;, 
    ylab = expression(paste(&quot;Average Temperature&quot;[&quot;t-1&quot;], &quot; &quot;, 
        (~degree * C))), las = 1, ylim = c(0.5, 4.5), yaxp = c(1, 
        4, 3), xlim = c(1995, 2015), xaxp = c(1995, 2015, 4), 
    cex = 1.5)
lines(xv, predict.mayaug.1)
text(1990, 4.5, substitute(italic(&quot;(c)&quot;)))</code></pre>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-17-1.png" width="288" /></p>
<hr />
</div>
</div>
<div id="recreating-figure-2" class="section level2">
<h2>5.3 Recreating Figure 2</h2>
<p>Now, we will work on re-creating Figure 2, which is a 4-panel figure with the average wing length of males and females (and error bars) for each species (panels <em>a</em> and <em>b</em>), and the relationship between average wing length and the average May-August temperature of the previous year (panels <em>c</em> and <em>d</em>).</p>
<div class="figure">
<img src="images/5.1_Fig2.png" alt="Figure 2 from Bowden et al. (2015): Inter-annual variation in average male (open circles) and female (filled circles) wing length over the sampling period for (a) Colias hecla and (b) Boloria chariclea and their responses (c,d, respectively) to average May–Augustt21 temperature. Error bars represent s.e. Data for 2010 are not available." />
<p class="caption">Figure 2 from Bowden et al. (2015): <em>Inter-annual variation in average male (open circles) and female (filled circles) wing length over the sampling period for (a) Colias hecla and (b) Boloria chariclea and their responses (c,d, respectively) to average May–Augustt21 temperature. Error bars represent s.e. Data for 2010 are not available.</em></p>
</div>
<hr />
<div id="panels-a-and-b-plotting-the-mean-wing-lengths-by-year-species-and-sex" class="section level3">
<h3>5.3.1 Panels (a) and (b): Plotting the mean wing lengths by year, species and sex</h3>
<p>First thing we need to do to construct this figure is to calculate the mean wing lengths for each year for each species and sex. We can do this with the <code>aggregate()</code> function that we used in a previous module:</p>
<p>Let’s start with <em>Colias hecla</em> since that is the first panel.</p>
<pre class="r"><code>wl.colias = aggregate(WL ~ year + sex, data = colias, mean)  #calculate the mean of WL by year and sex for the colias dataset.
head(wl.colias)</code></pre>
<pre><code>##   year sex       WL
## 1 1996   f 23.50433
## 2 1997   f 23.03800
## 3 1998   f 23.14333
## 4 1999   f 23.66786
## 5 2000   f 22.92941
## 6 2001   f 23.05778</code></pre>
<p>Ok, so now we have the data that we need to plot the means for each year.</p>
<p>Since the column called ‘WL’ actually represents the mean values, let’s change the column names to reflect that:</p>
<pre class="r"><code>names(wl.colias) = c(&quot;year&quot;, &quot;sex&quot;, &quot;mean&quot;)</code></pre>
<p>Let’s start building panel <em>a</em>. What we want to do is plot the data for one sex (say female), and then add the points for the second sex (male) on that same plot. To do this, a useful function is <code>subset()</code>, which allows us to easily specify a subset of data. Try this to plot the data for just the females:</p>
<pre class="r"><code>plot(mean ~ year, data = subset(wl.colias, sex == &quot;f&quot;), type = &quot;b&quot;, 
    pch = 19)</code></pre>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-21-1.png" width="384" /></p>
<p>Ok, so now what we have to do is plot this with the proper axis limits and then add the male data:</p>
<pre class="r"><code>plot(mean ~ year, data = subset(wl.colias, sex == &quot;f&quot;), type = &quot;b&quot;, 
    pch = 19, ylim = c(21, 24), xlim = c(1996, 2013), las = 1)
points(mean ~ year, data = subset(wl.colias, sex == &quot;m&quot;), type = &quot;b&quot;, 
    pch = 1)</code></pre>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-23-1.png" width="384" /></p>
<p>Notice that there is one problem here, which is that the plot connects the dots between the years 2009 and 2011, even though the data for 2010 is missing. The figure in the publication correctly omits this line. We will address this later.</p>
<hr />
</div>
<div id="creating-a-custom-function-to-calculate-standard-error-of-the-mean" class="section level3">
<h3>5.3.2 Creating a custom function to calculate standard error of the mean</h3>
<p>Figure 2(a) and 2(b) have standard error bars associated with each mean value. Let’s work on adding those. The base package in R famously does not have a built-in function for calculating standard error of the mean, but it is very easy to calculate it.</p>
<p>So, what is standard error? Simply, it is the standard deviation <span class="math inline">\(\sigma\)</span> divided by the square-root of the sample size <span class="math inline">\(n\)</span>: <span class="math display">\[SE = \frac{\sigma}{\sqrt n}\]</span> In turn, standard deviation <span class="math inline">\(\sigma\)</span> is simply the square-root of the variance <span class="math inline">\(\sigma^2\)</span>. Thus, <span class="math display">\[SE = \sqrt{\frac{\sigma^2}{n}}\]</span> So, to calculate the standard error of the mean of a vector, say WL, we simply need to do:</p>
<pre class="r"><code>sqrt(var(colias$WL)/length(colias$WL))  #the standard error of the mean of WL for the entire sample of Colias butterflies. </code></pre>
<pre><code>## [1] 0.0366356</code></pre>
<p>So, what we need to do is figure out an easy way to do this calculation for each year-species-sex. The best way to do this is to <strong><em>build a custom function</em></strong> to calculate the standard error, and then use this function within the <code>aggregate()</code> function (like we did to calculate the means)!</p>
<p>To create a custom function, we need to use <code>function()</code>. Inside the parentheses, we designate some variable(s). Here, we will call this variable <code>x</code>. Then, we use curly brackets <code>{}</code> to tell R what this function will do. Here is how to build a custom function called <code>se()</code> that will calculate the standard error of the mean:</p>
<pre class="r"><code>se = function(x) {
    sqrt(var(x)/length(x))
}  #create a new function called se() that will take a vector, x, and divide the variance of the vector by its length, then take its square-root.</code></pre>
<p>Now, let’s implement this function to the global sample of wing lengths in <em>Colias</em>:</p>
<pre class="r"><code>se(colias$WL)</code></pre>
<pre><code>## [1] 0.0366356</code></pre>
<p>This should give us the same value as our manual calculation above.</p>
<p>Now, we can calculate the standard error for each year, species and sex:</p>
<pre class="r"><code>wl.se.colias = aggregate(WL ~ year + sex, data = colias, se)
head(wl.se.colias)</code></pre>
<pre><code>##   year sex        WL
## 1 1996   f 0.1875043
## 2 1997   f 0.3290552
## 3 1998   f 0.7941522
## 4 1999   f 0.2076059
## 5 2000   f 0.2582698
## 6 2001   f 0.2911318</code></pre>
<pre class="r"><code># let&#39;s add the standard errors to the wl.colias dataframe
wl.colias$se = wl.se.colias[, 3]
head(wl.colias)</code></pre>
<pre><code>##   year sex     mean        se
## 1 1996   f 23.50433 0.1875043
## 2 1997   f 23.03800 0.3290552
## 3 1998   f 23.14333 0.7941522
## 4 1999   f 23.66786 0.2076059
## 5 2000   f 22.92941 0.2582698
## 6 2001   f 23.05778 0.2911318</code></pre>
<p>Now we have the standard error values that correspond with each of the dots on the plot in our dataframe!</p>
<hr />
</div>
<div id="plotting-the-standard-error-bars-using-arrows" class="section level3">
<h3>5.3.3 Plotting the standard error bars using <code>arrows()</code></h3>
<p>There are a number of packages that helps you create plots with error bars. To do this, we’are actually going to use the <code>arrow()</code> function, which is for drawing arrows between two points, but can be co-opted for drawing error bars.<br />
Where do we want our error bars to go? Well, for any given error bar, the starting and ending x-axis coordinates are the years, and the y-axis coordinates are the mean + s.e. and mean - s.e. To see how this works, let’s try:</p>
<pre class="r"><code>par(mar = c(4, 4, 1, 2))

plot(mean ~ year, data = subset(wl.colias, sex == &quot;f&quot;), type = &quot;b&quot;, 
    pch = 19, ylim = c(21, 24), xlim = c(1996, 2013), las = 1)
points(mean ~ year, data = subset(wl.colias, sex == &quot;m&quot;), type = &quot;b&quot;, 
    pch = 1)
arrows(wl.colias$year, wl.colias$mean + wl.colias$se, wl.colias$year, 
    wl.colias$mean - wl.colias$se, code = 3)  #code=3 draws double-sided arrows</code></pre>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-28-1.png" width="480" /></p>
<p>So we can just amend the arrows function here to make the angles of the arrowheads to be 90 degrees and shorten the tips:</p>
<pre class="r"><code>par(mar = c(4, 4, 1, 2))
plot(mean ~ year, data = subset(wl.colias, sex == &quot;f&quot;), type = &quot;b&quot;, 
    pch = 19, ylim = c(21, 24), xlim = c(1996, 2013), las = 1)
points(mean ~ year, data = subset(wl.colias, sex == &quot;m&quot;), type = &quot;b&quot;, 
    pch = 1)
arrows(wl.colias$year, wl.colias$mean + wl.colias$se, wl.colias$year, 
    wl.colias$mean - wl.colias$se, code = 3, angle = 90, length = 0.05)</code></pre>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-29-1.png" width="384" /></p>
<p>That’s pretty close to Figure 2(a)</p>
<hr />
</div>
<div id="convert-the-plotting-routine-into-a-function" class="section level3">
<h3>5.3.4 Convert the plotting routine into a function</h3>
<p>Now, we are going to work on plotting both species data, and we will also plot the data properly by skipping the year when no data were collected (2010).</p>
<p>The first thing to do is to create an dataframe with means and s.e. for each year/sex for <em>Boloria chariclea</em></p>
<pre class="r"><code>wl.boloria = aggregate(WL ~ year + sex, data = boloria, mean)
ses = aggregate(WL ~ year + sex, data = boloria, se)
wl.boloria$se = ses[, 3]
names(wl.boloria) = c(&quot;year&quot;, &quot;sex&quot;, &quot;mean&quot;, &quot;se&quot;)
head(wl.boloria)</code></pre>
<pre><code>##   year sex     mean         se
## 1 1996   f 19.19530 0.04240713
## 2 1997   f 18.61404 0.07397037
## 3 1998   f 18.83433 0.14669437
## 4 1999   f 19.08135 0.15136673
## 5 2000   f 19.02211 0.05388168
## 6 2001   f 19.51500 0.14057050</code></pre>
<p>Great, now we have a summarized dataset for both species.</p>
<p>Now, we could copy and paste the whole plotting routine the we did for <em>Colias</em> and just replace the “colias” with “boloria”. However, let’s do something a bit more fancy–we will convert the plotting routine into a function, and then we can call different datasets and make the same kind of plot with different data.</p>
<p>For reasons that will become apparent in a minute, I am going to set up a function that adds points, lines and standard error bars to an existing plotting region. We will call this function <code>points_se()</code>.<br />
Unlike the previous function we made, this function will take up multiple lines of code. To do this, we follow <code>function()</code> with a curly bracket (<code>{</code>) and return. Then, we can write however many lines of code that will be executed as part of the new function. We just have to end it all by closing the curly bracket (<code>}</code>). Here is what the function will do:</p>
<ul>
<li>Take two parameters: (1) the dataframe, (2) fill-color of the points.</li>
<li>The function will assume we are plotting means and standard errors by year</li>
<li>plot the standard error bars first using the data<span class="math inline">\(mean and data\)</span>se</li>
<li>plot the lines and points second (so that it will go on top of the error bars)</li>
</ul>
<pre class="r"><code>points_se = function(data, color) {
    arrows(data$year, data$mean + data$se, data$year, data$mean - 
        data$se, code = 3, angle = 90, length = 0.05)
    points(data$year, data$mean, type = &quot;b&quot;, pch = 21, bg = color)
    # note: by using pch = 21, we can make points that will be
    # filled with color designated by &#39;bg=&#39;
}</code></pre>
<p>With this function, All we have to do is set up an empty plotting region with the appropriate axis ranges, and then we can add the dots, lines and error bars for any range of data in the same format.</p>
<p>Let’s use this to plot Figure 2(a) the way we did before. What we will do is first set up an empty plotting region by plotting the data as <code>type=&quot;n&quot;</code> (for “none”) with the appropriate axis ranges. Then, we will plot just the female data (with black dots) by designating the dataframe as a subset of the data in which <code>sex==&quot;f&quot;</code>. You can do this with a function called <code>subset()</code>.</p>
<pre class="r"><code>plot(WL ~ year, data = wl.colias, type = &quot;n&quot;, ylim = c(21, 24), 
    xlim = c(1996, 2013), las = 1)
points_se(x = &quot;year&quot;, y = &quot;WL&quot;, data = subset(wl.colias, sex == 
    &quot;f&quot;), color = &quot;black&quot;)  #plot just female data
points_se(x = &quot;year&quot;, y = &quot;WL&quot;, data = subset(wl.colias, sex == 
    &quot;m&quot;), color = &quot;white&quot;)  #plot just male data</code></pre>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-33-1.png" width="384" /></p>
<p>Great! Now here is where going through the trouble of setting up a plotting function pays off. First, it makes it easy to plot the <em>Boloria</em> data using the exact same plotting parameters (except the y-axis has to be adjusted because these butterflies are smaller).</p>
<pre class="r"><code>plot(WL ~ year, data = wl.boloria, type = &quot;n&quot;, ylim = c(17, 20), 
    xlim = c(1996, 2013), las = 1)
points_se(data = subset(wl.boloria, sex == &quot;f&quot;), color = &quot;black&quot;)  #plot just female data
points_se(data = subset(wl.boloria, sex == &quot;m&quot;), color = &quot;white&quot;)  #plot just male data</code></pre>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-35-1.png" width="384" /></p>
<p>To go further, we can fix the details like skipping the year 2010 by plotting the points for years &lt;2010 and years &gt;2010 separately for each sex and each species, all in two vertical panels. I’ll also adjust the tick marks a bit:</p>
<pre class="r"><code>par(mar = c(4, 4, 1, 2), mfrow = c(2, 1))

plot(mean ~ year, data = wl.colias, type = &quot;n&quot;, ylim = c(21, 
    24), xlim = c(1996, 2013), xaxp = c(1996, 2012, 4), yaxp = c(21, 
    24, 3), las = 1)
points_se(data = subset(wl.colias, sex == &quot;f&quot; &amp; year &lt; 2010), 
    color = &quot;black&quot;)  #plot just female data for years &lt;2010
points_se(data = subset(wl.colias, sex == &quot;f&quot; &amp; year &gt; 2010), 
    color = &quot;black&quot;)  #plot just female data for years &gt;2010
points_se(data = subset(wl.colias, sex == &quot;m&quot; &amp; year &lt; 2010), 
    color = &quot;white&quot;)  #plot just male data for years &lt;2010
points_se(data = subset(wl.colias, sex == &quot;m&quot; &amp; year &gt; 2010), 
    color = &quot;white&quot;)  #plot just male data for years &gt;2010

plot(mean ~ year, data = wl.boloria, type = &quot;n&quot;, ylim = c(17, 
    20), xlim = c(1996, 2013), xaxp = c(1996, 2012, 4), yaxp = c(17, 
    20, 3), las = 1)
points_se(data = subset(wl.boloria, sex == &quot;f&quot; &amp; year &lt; 2010), 
    color = &quot;black&quot;)
points_se(data = subset(wl.boloria, sex == &quot;f&quot; &amp; year &gt; 2010), 
    color = &quot;black&quot;)
points_se(data = subset(wl.boloria, sex == &quot;m&quot; &amp; year &lt; 2010), 
    color = &quot;white&quot;)
points_se(data = subset(wl.boloria, sex == &quot;m&quot; &amp; year &gt; 2010), 
    color = &quot;white&quot;)</code></pre>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-36-1.png" width="384" /></p>
<p>We’ve pretty much re-created Figure 2(a,b)!</p>
<p>Some things that are worth thinking about here are:</p>
<ul>
<li>When should I make a routine into a function?</li>
<li>What should be the parameters that my function can take?</li>
<li>Should I make the whole routine into a single function, or should I break the routine into multiple components?</li>
</ul>
<p>There is no single good answer to these questions. I have heard people say that you should convert a routine into a function if you are going to run a routine more than 3 times. Another rule of thumb is that if I am going to apply a complex routine to multiple datasets, it might be a good idea to make a function. If I just replicate a routine and just change the dataframe name, that means that any tweaks I make to the code will have to be tweaked in multiple places. If I just make a function, then I can tweak it just once and then re-run the function on multiple datasets.</p>
<hr />
</div>
</div>
<div id="figure-2cd" class="section level2">
<h2>5.4 Figure 2(c,d)</h2>
<p>Ok, the final plots to make are the Figures 2(c,d), which are plots of the relationships between average wing length of a population/year/sex and the May-August temperature of the previous year.<br />
The good news is that <strong>we have covered everything you need to know to make these figures!</strong> Think about it for a minute and see if you can visualize the steps you need to complete to get this data</p>
<hr />
<p>Ok, let’s start. To begin, let’s add another column to the “wl.colias” dataframe that is the temperature of the previosu year. To do this, we will use a <code>match()</code> function that is useful as a “lookup” function to merge two datasets together.</p>
<pre class="r"><code>wl.colias$mayaug.1 = year.dat[match(wl.colias$year, year.dat$year), 
    &quot;mayaug.1&quot;]
wl.boloria$mayaug.1 = year.dat[match(wl.boloria$year, year.dat$year), 
    &quot;mayaug.1&quot;]</code></pre>
<p>Now, we can make a scatterplot for each species where the average female wing lengths are filled black and males are filled white</p>
<pre class="r"><code>plot(mean ~ mayaug.1, data = wl.colias, pch = 21, bg = c(&quot;black&quot;, 
    &quot;white&quot;)[as.numeric(sex)], xlim = c(0, 5), las = 1, xlab = &quot;May-Aug temp (t-1)&quot;, 
    ylab = &quot;average wing length (mm)&quot;)</code></pre>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-39-1.png" width="384" /></p>
<p>Then, we need to fit a separate linear regression for males and females, and then we will add those lines.<br />
First, the linear models for each sex for <em>Colias</em></p>
<pre class="r"><code>fit.col_f = lm(mean ~ mayaug.1, data = subset(wl.colias, sex == 
    &quot;f&quot;))
fit.col_m = lm(mean ~ mayaug.1, data = subset(wl.colias, sex == 
    &quot;m&quot;))</code></pre>
<p>Now, add those lines to the plot:</p>
<pre class="r"><code>xv = c(0.89, 4.02)  #take the two extreme x-values I want the fit line to connect
predict.col.f = predict(fit.col_f, list(mayaug.1 = xv))  #get the y-values at the ends of the line for female
predict.col.m = predict(fit.col_m, list(mayaug.1 = xv))  #get the y-values at the ends of the line for male

plot(mean ~ mayaug.1, data = wl.colias, pch = 21, bg = c(&quot;black&quot;, 
    &quot;white&quot;)[as.numeric(sex)], xlim = c(0, 5), las = 1, xlab = &quot;May-Aug temp (t-1)&quot;, 
    ylab = &quot;average wing length (mm)&quot;)
lines(xv, predict.col.f)
lines(xv, predict.col.m)</code></pre>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-42-1.png" width="384" /></p>
<p>We can do the same thing with <em>Boloria</em>:</p>
<pre class="r"><code>fit.bol_f = lm(mean ~ mayaug.1, data = subset(wl.boloria, sex == 
    &quot;f&quot;))
fit.bol_m = lm(mean ~ mayaug.1, data = subset(wl.boloria, sex == 
    &quot;m&quot;))
par(mar = c(4, 4, 1, 2))
xv = c(0.89, 4.02)  #take the two extreme x-values I want the fit line to connect
predict.bol.f = predict(fit.bol_f, list(mayaug.1 = xv))  #get the y-values at the ends of the line for female
predict.bol.m = predict(fit.bol_m, list(mayaug.1 = xv))  #get the y-values at the ends of the line for male

plot(mean ~ mayaug.1, data = wl.boloria, pch = 21, bg = c(&quot;black&quot;, 
    &quot;white&quot;)[as.numeric(sex)], xlim = c(0, 5), las = 1, xlab = &quot;May-Aug temp (t-1)&quot;, 
    ylab = &quot;average wing length (mm)&quot;)
lines(xv, predict.bol.f)
lines(xv, predict.bol.m)</code></pre>
<p><img src="05.1.Plot_Bowden_files/figure-html/unnamed-chunk-43-1.png" width="384" /></p>
<hr />
<p>Ok, I hope you feel like you learned some things by going through this exercise!</p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Bowden, JJ, Eskildsen, A., et al. (2016) High-Arctic butterflies become smaller with rising temperatures. <em>Biology Letters</em> 11: 20150574.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Here, notice that technically speaking, “year” is not a continuous variable… one might conceivably argue that there are more appropriate statistical approach to analyzing this type of time-series data.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>The discrepancy between the values that come out of our analysis and what is reported in the publication arises because the supplementary data is actually missing one data point for the climate variables that is included in the final publication (year 2010). This seems to be due to the fact that butterflies were not measured in 2010, and so that year does not appear in the supplemental data. However, the climate data for that year is available, so it is included in the analysis presented in Figure 1.<a href="#fnref3">↩</a></p></li>
</ol>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
