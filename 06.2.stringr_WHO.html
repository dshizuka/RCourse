<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Dai Shizuka" />


<title>Parsing dates and text</title>

<script src="site_libs/header-attrs-2.22/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/sandstone.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Intro to R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="syllabus.html">Syllabus</a>
</li>
<li>
  <a href="modules.html">Modules</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Parsing dates and text</h1>
<h4 class="author">Dai Shizuka</h4>
<h4 class="date">updated 01/07/24</h4>

</div>


<hr />
<div id="getting-data-buried-in-text" class="section level2">
<h2>1. Getting data buried in text</h2>
<p>There are many cases in which your analysis pipeline needs to include
steps to extract that data from the characters, rather than having to
code it manually yourself.</p>
<ul>
<li><p>This is the case with large datasets where important data is
stored in column names or file names.</p></li>
<li><p>Dates in datasets are also often interpreted as characters in
R.</p></li>
<li><p>In other cases, you might also conduct “text mining” analyses
where you look for particular words and codes inside large amounts of
documents, websites, etc.</p></li>
</ul>
<p>R has different ways to deal with dates and texts, both in base R and
in the tidyverse packages.</p>
<p>For this module, we will make use of two packages from the tidyverse
family: <em>stringr</em> and <em>lubridate</em>:</p>
<pre class="r"><code>library(tidyverse)
library(lubridate)</code></pre>
</div>
<div id="section" class="section level2">
<h2></h2>
<p>Get the stringr cheatsheet <a
href="https://raw.githubusercontent.com/rstudio/cheatsheets/main/strings.pdf">here</a></p>
<p>Get the lubridate cheatsheet <a
href="https://github.com/rstudio/cheatsheets/blob/main/lubridate.pdf">here</a></p>
<hr />
</div>
<div id="dealing-with-dates" class="section level2">
<h2>2. Dealing with dates</h2>
<div id="dates-treated-as-characters-when-importing-data"
class="section level3">
<h3>2.1 Dates treated as characters when importing data:</h3>
<p>Let’s take the <code>presidential</code> dataset that is included in
the ggplot2 package:</p>
<pre class="r"><code>presidential</code></pre>
<pre><code>## # A tibble: 12 × 4
##    name       start      end        party     
##    &lt;chr&gt;      &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;     
##  1 Eisenhower 1953-01-20 1961-01-20 Republican
##  2 Kennedy    1961-01-20 1963-11-22 Democratic
##  3 Johnson    1963-11-22 1969-01-20 Democratic
##  4 Nixon      1969-01-20 1974-08-09 Republican
##  5 Ford       1974-08-09 1977-01-20 Republican
##  6 Carter     1977-01-20 1981-01-20 Democratic
##  7 Reagan     1981-01-20 1989-01-20 Republican
##  8 Bush       1989-01-20 1993-01-20 Republican
##  9 Clinton    1993-01-20 2001-01-20 Democratic
## 10 Bush       2001-01-20 2009-01-20 Republican
## 11 Obama      2009-01-20 2017-01-20 Democratic
## 12 Trump      2017-01-20 2021-01-20 Republican</code></pre>
<p>As this is a pre-loaded package, you can see that the “start” and
“end” dates of each president is already recognized as a “date”
object:</p>
<pre class="r"><code>class(presidential$start)</code></pre>
<pre><code>## [1] &quot;Date&quot;</code></pre>
<p>This means that you can do things that you might expect to do with
time data, like calculate the number of days between the start and end
dates:</p>
<pre class="r"><code>presidential$end - presidential$start</code></pre>
<pre><code>## Time differences in days
##  [1] 2922 1036 1886 2027  895 1461 2922 1461 2922 2922 2922 1461</code></pre>
<p>But let’s what happens if we were to import this dataset from a .csv
format!</p>
<p>First, write the data as a .csv file…</p>
<pre class="r"><code>write.csv(presidential, &quot;data/presidential.csv&quot;, row.names = F)</code></pre>
<p>… then read it in, calling it something slightly different to make
sure we can distinguish it from the original prepackaged dataset.</p>
<pre class="r"><code>pres.dat=read.csv(&quot;data/presidential.csv&quot;)</code></pre>
<p>Now see what this looks like.</p>
<pre class="r"><code>pres.dat</code></pre>
<pre><code>##          name      start        end      party
## 1  Eisenhower 1953-01-20 1961-01-20 Republican
## 2     Kennedy 1961-01-20 1963-11-22 Democratic
## 3     Johnson 1963-11-22 1969-01-20 Democratic
## 4       Nixon 1969-01-20 1974-08-09 Republican
## 5        Ford 1974-08-09 1977-01-20 Republican
## 6      Carter 1977-01-20 1981-01-20 Democratic
## 7      Reagan 1981-01-20 1989-01-20 Republican
## 8        Bush 1989-01-20 1993-01-20 Republican
## 9     Clinton 1993-01-20 2001-01-20 Democratic
## 10       Bush 2001-01-20 2009-01-20 Republican
## 11      Obama 2009-01-20 2017-01-20 Democratic
## 12      Trump 2017-01-20 2021-01-20 Republican</code></pre>
<p>You’ll notice that the “start” and “end” dates are now recognized as
characters. This means that you can’t treat them like dates. For
example, you wouldn’t be able to calculate the number of dates between
start and end of the presidency:</p>
<pre class="r"><code>pres.dat$end - pres.dat$start</code></pre>
<pre><code>## Error in pres.dat$end - pres.dat$start : 
##  non-numeric argument to binary operator</code></pre>
</div>
<div id="turning-dates-as-characters-into-date-objects"
class="section level3">
<h3>2.2. Turning dates-as-characters into “date” objects</h3>
<p>You can take a date-as-character to turn it into a date object either
in base R or using the <code>lubridate</code> package.</p>
<div id="the-base-r-way" class="section level4">
<h4>The base R way:</h4>
<pre class="r"><code>as.Date(pres.dat$start, format=&quot;%Y-%m-%d&quot;)</code></pre>
<pre><code>##  [1] &quot;1953-01-20&quot; &quot;1961-01-20&quot; &quot;1963-11-22&quot; &quot;1969-01-20&quot; &quot;1974-08-09&quot;
##  [6] &quot;1977-01-20&quot; &quot;1981-01-20&quot; &quot;1989-01-20&quot; &quot;1993-01-20&quot; &quot;2001-01-20&quot;
## [11] &quot;2009-01-20&quot; &quot;2017-01-20&quot;</code></pre>
<p>In using the <code>as.Date()</code> function, you have to use the
<code>format=</code> argument to specify the format the date is in.</p>
<p>Here are the options to include in the format argument:</p>
<table>
<thead>
<tr class="header">
<th align="center">Symbol</th>
<th align="center">Meaning</th>
<th align="center">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">%d</td>
<td align="center">day as a number (0-31)</td>
<td align="center">01-31</td>
</tr>
<tr class="even">
<td align="center">%a</td>
<td align="center">abbreviated weekday</td>
<td align="center">Mon</td>
</tr>
<tr class="odd">
<td align="center">%A</td>
<td align="center">unabbreviated weekday</td>
<td align="center">Monday</td>
</tr>
<tr class="even">
<td align="center">%m</td>
<td align="center">month (00-12)</td>
<td align="center">00-12</td>
</tr>
<tr class="odd">
<td align="center">%b</td>
<td align="center">abbreviated month</td>
<td align="center">Jan</td>
</tr>
<tr class="even">
<td align="center">%B</td>
<td align="center">unabbreviated month</td>
<td align="center">January</td>
</tr>
<tr class="odd">
<td align="center">%y</td>
<td align="center">2-digit year</td>
<td align="center">07</td>
</tr>
<tr class="even">
<td align="center">%Y</td>
<td align="center">4-digit year</td>
<td align="center">2007</td>
</tr>
</tbody>
</table>
<p>Note that you have to be specific and correct. For example, if you
use “%y” instead of “%Y” when you have a four-digit year, the function
will not be able to parse it:</p>
<pre class="r"><code>as.Date(pres.dat$start, format=&quot;%y-%m-%d&quot;)</code></pre>
<pre><code>##  [1] NA NA NA NA NA NA NA NA NA NA NA NA</code></pre>
<p>But once you learn how to use this, it becomes easier.</p>
<p>Say you have your data in “month/date/year” format (common in the
U.S.):</p>
<pre class="r"><code>mdy_dates=c(&quot;5/17/1978&quot;, &quot;3/23/2022&quot;)
as.Date(mdy_dates, format=&quot;%m/%d/%Y&quot;)</code></pre>
<pre><code>## [1] &quot;1978-05-17&quot; &quot;2022-03-23&quot;</code></pre>
</div>
<div id="now-lets-try-the-same-exercise-using-the-lubridate-package."
class="section level4">
<h4>Now, let’s try the same exercise using the <code>lubridate</code>
package.</h4>
<p><code>lubridate</code> has a handy functions that simplify the
processing of converting dates-as-characters into date objects:</p>
<p>For example, since the start and end dates are in “year-month-date”
format, we can use a function called <code>ymd()</code>:</p>
<pre class="r"><code>ymd(pres.dat$start)</code></pre>
<pre><code>##  [1] &quot;1953-01-20&quot; &quot;1961-01-20&quot; &quot;1963-11-22&quot; &quot;1969-01-20&quot; &quot;1974-08-09&quot;
##  [6] &quot;1977-01-20&quot; &quot;1981-01-20&quot; &quot;1989-01-20&quot; &quot;1993-01-20&quot; &quot;2001-01-20&quot;
## [11] &quot;2009-01-20&quot; &quot;2017-01-20&quot;</code></pre>
<p>To see that this actually converts these character strings into
dates, let’s try calculating the number of days of each presidency:</p>
<pre class="r"><code>ymd(pres.dat$end) - ymd(pres.dat$start)</code></pre>
<pre><code>## Time differences in days
##  [1] 2922 1036 1886 2027  895 1461 2922 1461 2922 2922 2922 1461</code></pre>
<p>Now let’s try the “month/date/year” format. We’ll re-create the
simple character string from before:</p>
<pre class="r"><code>mdy_dates=c(&quot;5/17/1978&quot;, &quot;3/23/2022&quot;)</code></pre>
<p>Since the year, month and date are in a different order now, the
<code>ymd()</code> function cannot process this:</p>
<pre class="r"><code>ymd(mdy_dates)</code></pre>
<pre><code>## Warning: All formats failed to parse. No formats found.</code></pre>
<pre><code>## [1] NA NA</code></pre>
<p>But we can simply use a friendly alternative function,
<code>mdy()</code>:</p>
<pre class="r"><code>mdy(mdy_dates)</code></pre>
<pre><code>## [1] &quot;1978-05-17&quot; &quot;2022-03-23&quot;</code></pre>
</div>
</div>
</div>
<div id="extracting-replacing-and-splitting-character-strings"
class="section level2">
<h2>3. Extracting, Replacing, and Splitting character strings</h2>
<p>Let’s start with a hypothetical example. What if I had named my data
files with the date:</p>
<pre class="r"><code>filename=&quot;data_20220927.csv&quot;</code></pre>
<p>Now, let’s say I wanted to extract the dates from file names as part
of my analyses. The basic way I might do this is through “text
parsing”–i.e., extracting parts of text to get useful data. Here, I know
that my file name has useful information (i.e., the year, month and
date).</p>
<p>I’m going to show you three ways to do this, using base R and the
<code>stringr</code> package for each.</p>
<div id="extracting-substrings-using-fixed-positions"
class="section level3">
<h3>3.1. Extracting substrings using fixed positions</h3>
<p>One way to get the date from the file name is to just extract the
part of this character string that contains the information I want.</p>
<p>If I just **count the start and stop position* of the information
within this character string, I can just extract that part of the string
(i.e., substring). In this case, the date (“20200927”) goes from
position 6 to position 13 in this character.</p>
<p>I can use the <code>substr()</code> function in base R to do
this:</p>
<pre class="r"><code>substr(filename, start=6, stop=13)</code></pre>
<pre><code>## [1] &quot;20220927&quot;</code></pre>
<p>Alternatively, I can use the <code>str_sub()</code> function in
<em>stringr</em> in the same way.</p>
<pre class="r"><code>str_sub(filename, start=6, end=13)</code></pre>
<pre><code>## [1] &quot;20220927&quot;</code></pre>
<p>… and once I have this substring, I can convert this into a date
object.</p>
<p>I can do this in base R, using the <code>as.Date()</code> function.
To use this function, you need to specify the format in which the
character string encodes the date information. Here, since it is a
4-number code for year, followed by month and date, you would put
“%Y%m%d”.</p>
<pre class="r"><code>as.Date(substr(filename, start=6, stop=13), format=&quot;%Y%m%d&quot;)</code></pre>
<pre><code>## [1] &quot;2022-09-27&quot;</code></pre>
<p>Alternatively, you can use the <code>ymd()</code> function in
<em>lubridate</em>. This function is a bit smarter in that it is more
flexible–it can parse the text correctly as long as it’s in some form of
year-month-date order. (If it was in month-date-year, you would use the
<code>mdy()</code> function).</p>
<pre class="r"><code>filename %&gt;% str_sub(start=6, end=13) %&gt;% ymd()</code></pre>
<pre><code>## [1] &quot;2022-09-27&quot;</code></pre>
<p><strong>Extracting substrings is probably the most straightforward
way to parse text. HOWEVER, you can only do this if the text is
formatted in a way that makes the position of your information of
interest predictable</strong></p>
<hr />
</div>
<div id="replacing-characters" class="section level3">
<h3>3.2. Replacing characters</h3>
<p>You could also extract the date from the file name by substituting
<em>blanks</em> for the parts that you don’t want (i.e., “data_” and
“.csv”).</p>
<p>In base R, you can do this with <code>gsub()</code>. For example:</p>
<pre class="r"><code>gsub(&quot;data_&quot;, &quot;&quot;, filename) #this removes &quot;data_&quot; from the character string</code></pre>
<pre><code>## [1] &quot;20220927.csv&quot;</code></pre>
<p>So you can string this together, then convert to date:</p>
<pre class="r"><code>a=gsub(&quot;data_&quot;, &quot;&quot;, filename) #remove the prefix
b=gsub(&quot;.csv&quot;, &quot;&quot;, a) #remove the suffix
as.Date(b, format=&quot;%Y%m%d&quot;) #convert to date object</code></pre>
<pre><code>## [1] &quot;2022-09-27&quot;</code></pre>
<p>Using the <em>stringr</em> function <code>str_replace()</code> in the
same way:</p>
<p>Let’s try using the pipe and <code>str_replace()</code> to get rid of
the first part of the file name:</p>
<pre class="r"><code>filename %&gt;% str_replace(&quot;data_&quot;, &quot;&quot;)</code></pre>
<pre><code>## [1] &quot;20220927.csv&quot;</code></pre>
<p>Using the same principle, we can string together the
<code>str_replace()</code> functions and convert the result to a date
object using <code>ymd()</code>:</p>
<pre class="r"><code>filename %&gt;% 
  str_replace(&quot;data_&quot;, &quot;&quot;) %&gt;% 
  str_replace(&quot;.csv&quot;, &quot;&quot;) %&gt;% 
  ymd()</code></pre>
<pre><code>## [1] &quot;2022-09-27&quot;</code></pre>
<hr />
</div>
<div id="splitting-characters" class="section level3">
<h3>3.3. Splitting characters</h3>
<p>Another option is to split the character string into multiple
elements. You can specify the character you use as the marker for where
you want to split the character string. This is a very powerful and
flexible tool, though it requires you to have a good understanding of
how to deal with lists… So it is probably best reserved for complex
tasks that you can’t do with substrings or text replacement.</p>
<p>For example, if we split the file name at the underscore (“_“):</p>
<pre class="r"><code>strsplit(filename, split=c(&quot;_&quot;))</code></pre>
<pre><code>## [[1]]
## [1] &quot;data&quot;         &quot;20220927.csv&quot;</code></pre>
<pre class="r"><code>strsplit(filename, split=c(&quot;.&quot;), fixed=T)</code></pre>
<pre><code>## [[1]]
## [1] &quot;data_20220927&quot; &quot;csv&quot;</code></pre>
<pre class="r"><code>a=strsplit(filename, split=c(&quot;_&quot;))
a</code></pre>
<pre><code>## [[1]]
## [1] &quot;data&quot;         &quot;20220927.csv&quot;</code></pre>
<p>Now, the next step is to split the remaining string “20220927.csv” by
the period (“.”). However, this is a bit challenging because R does not
handle the character “.” simply as a period. To do this, you have to use
the Regular Expression for a period, which is “\.”</p>
<pre class="r"><code>strsplit(a[[1]], split=c(&quot;\\.&quot;))</code></pre>
<pre><code>## [[1]]
## [1] &quot;data&quot;
## 
## [[2]]
## [1] &quot;20220927&quot; &quot;csv&quot;</code></pre>
<pre class="r"><code>b=strsplit(a[[1]], split=c(&quot;\\.&quot;))
b</code></pre>
<pre><code>## [[1]]
## [1] &quot;data&quot;
## 
## [[2]]
## [1] &quot;20220927&quot; &quot;csv&quot;</code></pre>
<pre class="r"><code>b[[2]][1]</code></pre>
<pre><code>## [1] &quot;20220927&quot;</code></pre>
<pre class="r"><code>s=b[[2]][1]
as.Date(s, format=&quot;%Y%m%d&quot;) #convert to date object</code></pre>
<pre><code>## [1] &quot;2022-09-27&quot;</code></pre>
<pre class="r"><code>str_split_1(filename, pattern=c(&quot;_&quot;)) %&gt;%
  str_split(.,pattern=c(&quot;\\.&quot;))</code></pre>
<pre><code>## [[1]]
## [1] &quot;data&quot;
## 
## [[2]]
## [1] &quot;20220927&quot; &quot;csv&quot;</code></pre>
<p>From here, you can use the same process as the base R case to extract
the number.</p>
<hr />
</div>
<div id="pattern-matching" class="section level3">
<h3>3.4. Pattern Matching</h3>
<p>Finally, there may be cases where you don’t need to extract the whole
information, but you simply need to know if the character string
contains some pattern.</p>
<pre class="r"><code>filenames_vector=c(&quot;data_20220927.csv&quot;, &quot;data_20221121.csv&quot;, &quot;data_20230103.csv&quot;, &quot;data_20230308.csv&quot;)</code></pre>
<p>For example, let’s say you are scouring the file names for all files
pertaining to the year 2022. Then, perhaps all you need to know is
whether the file name contains “2022”.</p>
<p>You can find this out one of two ways.</p>
<p>The <code>grepl()</code> function will tell you TRUE or FALSE if the
character string does or does not contain the string you are looking
for:</p>
<pre class="r"><code>grepl(&quot;2022&quot;, filenames_vector)</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE FALSE</code></pre>
<p>In contrast, <code>grep()</code> will return the position of the
elements that matched your pattern:</p>
<pre class="r"><code>grep(&quot;2022&quot;, filenames_vector)</code></pre>
<pre><code>## [1] 1 2</code></pre>
<p>Then, you can extract the file names that contain “2022”.</p>
<pre class="r"><code>filenames_vector[grep(&quot;2022&quot;, filenames_vector)]</code></pre>
<pre><code>## [1] &quot;data_20220927.csv&quot; &quot;data_20221121.csv&quot;</code></pre>
<hr />
</div>
</div>
<div id="example-using-who-tuberculosis-data-under-construction"
class="section level2">
<h2>4. Example using WHO tuberculosis data (UNDER CONSTRUCTION)</h2>
<p>Let’s do an example of how one might use text parsing in the process
of data analysis.</p>
<p>For this example, we will use the <code>who</code> dataset, included
in tidyverse, which has data from the World Health Organization Global
Tuberculosis Report.</p>
<pre class="r"><code>who</code></pre>
<pre><code>## # A tibble: 7,240 × 60
##    country  iso2  iso3   year new_sp_m014 new_sp_m1524 new_sp_m2534 new_sp_m3544
##    &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;
##  1 Afghani… AF    AFG    1980          NA           NA           NA           NA
##  2 Afghani… AF    AFG    1981          NA           NA           NA           NA
##  3 Afghani… AF    AFG    1982          NA           NA           NA           NA
##  4 Afghani… AF    AFG    1983          NA           NA           NA           NA
##  5 Afghani… AF    AFG    1984          NA           NA           NA           NA
##  6 Afghani… AF    AFG    1985          NA           NA           NA           NA
##  7 Afghani… AF    AFG    1986          NA           NA           NA           NA
##  8 Afghani… AF    AFG    1987          NA           NA           NA           NA
##  9 Afghani… AF    AFG    1988          NA           NA           NA           NA
## 10 Afghani… AF    AFG    1989          NA           NA           NA           NA
## # ℹ 7,230 more rows
## # ℹ 52 more variables: new_sp_m4554 &lt;dbl&gt;, new_sp_m5564 &lt;dbl&gt;,
## #   new_sp_m65 &lt;dbl&gt;, new_sp_f014 &lt;dbl&gt;, new_sp_f1524 &lt;dbl&gt;,
## #   new_sp_f2534 &lt;dbl&gt;, new_sp_f3544 &lt;dbl&gt;, new_sp_f4554 &lt;dbl&gt;,
## #   new_sp_f5564 &lt;dbl&gt;, new_sp_f65 &lt;dbl&gt;, new_sn_m014 &lt;dbl&gt;,
## #   new_sn_m1524 &lt;dbl&gt;, new_sn_m2534 &lt;dbl&gt;, new_sn_m3544 &lt;dbl&gt;,
## #   new_sn_m4554 &lt;dbl&gt;, new_sn_m5564 &lt;dbl&gt;, new_sn_m65 &lt;dbl&gt;, …</code></pre>
<p>Also make sure to look at the help file for the dataset:</p>
<pre class="r"><code>?who</code></pre>
<p>First thing we see is that this data set is <em>terribly</em> wide.
There are 60 columns, 56 of which contain data on counts of TB cases,
and each of those 56 columns represents different combinations of method
of diagnosis, gender and age group.</p>
<p>These column names are where a lot of the important information are,
and what we might want to use as variables of interest.</p>
<p>So, let’s refresh our memory on how we can use the
<code>pivot_longer()</code> function to make this data into a “long
format”.</p>
<p>Start by using <code>pivot_longer()</code>, specifying that we want
to keep the first four columns as is:</p>
<pre class="r"><code>who_long=who %&gt;% pivot_longer(c(-country, -iso2, -iso3, -year))
who_long</code></pre>
<pre><code>## # A tibble: 405,440 × 6
##    country     iso2  iso3   year name         value
##    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;
##  1 Afghanistan AF    AFG    1980 new_sp_m014     NA
##  2 Afghanistan AF    AFG    1980 new_sp_m1524    NA
##  3 Afghanistan AF    AFG    1980 new_sp_m2534    NA
##  4 Afghanistan AF    AFG    1980 new_sp_m3544    NA
##  5 Afghanistan AF    AFG    1980 new_sp_m4554    NA
##  6 Afghanistan AF    AFG    1980 new_sp_m5564    NA
##  7 Afghanistan AF    AFG    1980 new_sp_m65      NA
##  8 Afghanistan AF    AFG    1980 new_sp_f014     NA
##  9 Afghanistan AF    AFG    1980 new_sp_f1524    NA
## 10 Afghanistan AF    AFG    1980 new_sp_f2534    NA
## # ℹ 405,430 more rows</code></pre>
<p>We can see that this creates a “name” column, which has the column
names we have pivoted, and a “value” column, which is where the count
data goes (the first 10 country x year combo happens to not have
data).</p>
<p>Ok, so using this, we are going to first ‘pull’ the variable called
“name” and see all of the unique values:</p>
<pre class="r"><code>#get the codes: pull() is a function to get one variable out of a dataframe
who_long %&gt;% pull(name) %&gt;% unique()</code></pre>
<pre><code>##  [1] &quot;new_sp_m014&quot;  &quot;new_sp_m1524&quot; &quot;new_sp_m2534&quot; &quot;new_sp_m3544&quot; &quot;new_sp_m4554&quot;
##  [6] &quot;new_sp_m5564&quot; &quot;new_sp_m65&quot;   &quot;new_sp_f014&quot;  &quot;new_sp_f1524&quot; &quot;new_sp_f2534&quot;
## [11] &quot;new_sp_f3544&quot; &quot;new_sp_f4554&quot; &quot;new_sp_f5564&quot; &quot;new_sp_f65&quot;   &quot;new_sn_m014&quot; 
## [16] &quot;new_sn_m1524&quot; &quot;new_sn_m2534&quot; &quot;new_sn_m3544&quot; &quot;new_sn_m4554&quot; &quot;new_sn_m5564&quot;
## [21] &quot;new_sn_m65&quot;   &quot;new_sn_f014&quot;  &quot;new_sn_f1524&quot; &quot;new_sn_f2534&quot; &quot;new_sn_f3544&quot;
## [26] &quot;new_sn_f4554&quot; &quot;new_sn_f5564&quot; &quot;new_sn_f65&quot;   &quot;new_ep_m014&quot;  &quot;new_ep_m1524&quot;
## [31] &quot;new_ep_m2534&quot; &quot;new_ep_m3544&quot; &quot;new_ep_m4554&quot; &quot;new_ep_m5564&quot; &quot;new_ep_m65&quot;  
## [36] &quot;new_ep_f014&quot;  &quot;new_ep_f1524&quot; &quot;new_ep_f2534&quot; &quot;new_ep_f3544&quot; &quot;new_ep_f4554&quot;
## [41] &quot;new_ep_f5564&quot; &quot;new_ep_f65&quot;   &quot;newrel_m014&quot;  &quot;newrel_m1524&quot; &quot;newrel_m2534&quot;
## [46] &quot;newrel_m3544&quot; &quot;newrel_m4554&quot; &quot;newrel_m5564&quot; &quot;newrel_m65&quot;   &quot;newrel_f014&quot; 
## [51] &quot;newrel_f1524&quot; &quot;newrel_f2534&quot; &quot;newrel_f3544&quot; &quot;newrel_f4554&quot; &quot;newrel_f5564&quot;
## [56] &quot;newrel_f65&quot;</code></pre>
<p>The help file provides the codes:</p>
<ul>
<li>all codes start with “new”</li>
<li>the next part codes the method of diagnosis. It is either “rel”,
“_sn”, “_sp”, or “_ep”… notice that the under score ensures that they
are all 3 characters long.</li>
<li>next part is “_m” for male and “_f” for female. These are all 2
characters long</li>
<li>final part has different number of characters: 014 = 0-14 yrs of
age, 1524 = 15-24 years of age, 2534 = 25 to 34 years of age, 3544 = 35
to 44 years of age, 4554 = 45 to 54 years of age, 5564 = 55 to 64 years
of age, 65 = 65 years of age or older</li>
</ul>
<p>So, let’s get the gender from those columns.</p>
<p>We can see that the code for gender (“f” for female, “m” for male) is
ALWAYS the 8th character of the string. This makes our life easy–we just
need to get the 8th character. We can do that using
<code>str_sub()</code> to extract the substring:</p>
<pre class="r"><code>who_long %&gt;% pull(name) %&gt;% str_sub(start=8, end=8) %&gt;% unique()</code></pre>
<pre><code>## [1] &quot;m&quot; &quot;f&quot;</code></pre>
<p>So we can use this to create a new column called “gender” in the
who_long dataset.</p>
<p>To do this, we will use the <code>mutate()</code> function, and use
the <code>str_sub()</code> within it. In that function, we specify that
we are taking the variable “name” and taking the 8th character.</p>
<pre class="r"><code>who_long %&gt;%
  mutate(gender=str_sub(name, start=8, end=8))</code></pre>
<pre><code>## # A tibble: 405,440 × 7
##    country     iso2  iso3   year name         value gender
##    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt; 
##  1 Afghanistan AF    AFG    1980 new_sp_m014     NA m     
##  2 Afghanistan AF    AFG    1980 new_sp_m1524    NA m     
##  3 Afghanistan AF    AFG    1980 new_sp_m2534    NA m     
##  4 Afghanistan AF    AFG    1980 new_sp_m3544    NA m     
##  5 Afghanistan AF    AFG    1980 new_sp_m4554    NA m     
##  6 Afghanistan AF    AFG    1980 new_sp_m5564    NA m     
##  7 Afghanistan AF    AFG    1980 new_sp_m65      NA m     
##  8 Afghanistan AF    AFG    1980 new_sp_f014     NA f     
##  9 Afghanistan AF    AFG    1980 new_sp_f1524    NA f     
## 10 Afghanistan AF    AFG    1980 new_sp_f2534    NA f     
## # ℹ 405,430 more rows</code></pre>
<p>Next, let’s try to extract the method of diagnosis. This information
is always contained between the 4th and 6th characters of the “name”
variable:</p>
<p>Let’s pull the “name” variable, get the 4th through 6th character,
and see all unique values:</p>
<pre class="r"><code>who_long %&gt;% pull(name) %&gt;% str_sub(start=4, end=6) %&gt;% unique()</code></pre>
<pre><code>## [1] &quot;_sp&quot; &quot;_sn&quot; &quot;_ep&quot; &quot;rel&quot;</code></pre>
<p>You can see that this value can be either “rel” for relapse, or “sp”,
“sn”, “ep”. For the latter three, there is a preceding “_” to make it
the same number of character (I see why, but not ideal… they could have
just use the same number of letters throughout…).</p>
<p>So what we can do is to go ahead and extract the 4th to 6th character
and then remove the underscore if it exists.</p>
<p>Remove the underscore “_” if it is exists.</p>
<pre class="r"><code>who_long %&gt;%
  mutate(gender=str_sub(name, start=8, end=8)) %&gt;%
  mutate(method=str_sub(name, 4, 6)) %&gt;%
  mutate(method=str_replace(method, &quot;_&quot;, &quot;&quot;))</code></pre>
<pre><code>## # A tibble: 405,440 × 8
##    country     iso2  iso3   year name         value gender method
##    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt; 
##  1 Afghanistan AF    AFG    1980 new_sp_m014     NA m      sp    
##  2 Afghanistan AF    AFG    1980 new_sp_m1524    NA m      sp    
##  3 Afghanistan AF    AFG    1980 new_sp_m2534    NA m      sp    
##  4 Afghanistan AF    AFG    1980 new_sp_m3544    NA m      sp    
##  5 Afghanistan AF    AFG    1980 new_sp_m4554    NA m      sp    
##  6 Afghanistan AF    AFG    1980 new_sp_m5564    NA m      sp    
##  7 Afghanistan AF    AFG    1980 new_sp_m65      NA m      sp    
##  8 Afghanistan AF    AFG    1980 new_sp_f014     NA f      sp    
##  9 Afghanistan AF    AFG    1980 new_sp_f1524    NA f      sp    
## 10 Afghanistan AF    AFG    1980 new_sp_f2534    NA f      sp    
## # ℹ 405,430 more rows</code></pre>
<p>Finally, let’s get the age class:</p>
<p>This code part of the code starts on the 9th character, but can
contain two characters (“65”), three characters (“014”) or four
characters (“1524”, “2534”, “3544”, “4554”, or “5564”). What we can do
is to use the str_sub() function but just give it the starting character
number:</p>
<pre class="r"><code>who_long %&gt;% pull(name) %&gt;% str_sub(start=9) %&gt;% unique()</code></pre>
<pre><code>## [1] &quot;014&quot;  &quot;1524&quot; &quot;2534&quot; &quot;3544&quot; &quot;4554&quot; &quot;5564&quot; &quot;65&quot;</code></pre>
<p>Ok, now we want to convert this into something that makes more sense
when we are plotting it…</p>
<p>What we can do is to replace each of the age codes to readable age
categories and then convert it into a factor using
<code>as_factor()</code></p>
<pre class="r"><code>who_long %&gt;% pull(name) %&gt;% str_sub(start=9) %&gt;%
  str_replace(&quot;014&quot;, &quot;0-14&quot;) %&gt;%
  str_replace(&quot;1524&quot;, &quot;15-24&quot;) %&gt;%
  str_replace(&quot;2534&quot;, &quot;25-34&quot;) %&gt;%
  str_replace(&quot;3544&quot;, &quot;35-44&quot;) %&gt;%
  str_replace(&quot;4554&quot;, &quot;45-54&quot;) %&gt;%
  str_replace(&quot;5564&quot;, &quot;55-64&quot;) %&gt;%
  str_replace(&quot;65&quot;, &quot;65+&quot;) %&gt;%
  as_factor() %&gt;%
  head()</code></pre>
<pre><code>## [1] 0-14  15-24 25-34 35-44 45-54 55-64
## Levels: 0-14 15-24 25-34 35-44 45-54 55-64 65+</code></pre>
<p>We can use this within a <code>mutate</code> function: Let’s do that
and save it as a new dataframe:</p>
<pre class="r"><code>who_use=who_long %&gt;%
  mutate(gender=str_sub(name, start=8, end=8)) %&gt;%
  mutate(method=str_sub(name, 4, 6)) %&gt;%
  mutate(method=str_replace(method, &quot;_&quot;, &quot;&quot;)) %&gt;%
  mutate(age=str_sub(name, start=9) %&gt;%
           str_replace(&quot;014&quot;, &quot;0-14&quot;) %&gt;%
           str_replace(&quot;1524&quot;, &quot;15-24&quot;) %&gt;%
           str_replace(&quot;2534&quot;, &quot;25-34&quot;) %&gt;%
           str_replace(&quot;3544&quot;, &quot;35-44&quot;) %&gt;%
           str_replace(&quot;4544&quot;, &quot;45-54&quot;) %&gt;%
           str_replace(&quot;5564&quot;, &quot;55-64&quot;) %&gt;%
           str_replace(&quot;65&quot;, &quot;65+&quot;) %&gt;%
           as_factor())

who_use</code></pre>
<pre><code>## # A tibble: 405,440 × 9
##    country     iso2  iso3   year name         value gender method age  
##    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;fct&gt;
##  1 Afghanistan AF    AFG    1980 new_sp_m014     NA m      sp     0-14 
##  2 Afghanistan AF    AFG    1980 new_sp_m1524    NA m      sp     15-24
##  3 Afghanistan AF    AFG    1980 new_sp_m2534    NA m      sp     25-34
##  4 Afghanistan AF    AFG    1980 new_sp_m3544    NA m      sp     35-44
##  5 Afghanistan AF    AFG    1980 new_sp_m4554    NA m      sp     4554 
##  6 Afghanistan AF    AFG    1980 new_sp_m5564    NA m      sp     55-64
##  7 Afghanistan AF    AFG    1980 new_sp_m65      NA m      sp     65+  
##  8 Afghanistan AF    AFG    1980 new_sp_f014     NA f      sp     0-14 
##  9 Afghanistan AF    AFG    1980 new_sp_f1524    NA f      sp     15-24
## 10 Afghanistan AF    AFG    1980 new_sp_f2534    NA f      sp     25-34
## # ℹ 405,430 more rows</code></pre>
<p>Now, we can plot some trends, making use of out new variables for
filtering data and using them as variables of interest:</p>
<p>For example, how has the prevalence of TB changed across years in the
U.S. for those over 65, detected using positive pulmonary smears
(method==“sp”), and breaking down the trend by gender?</p>
<pre class="r"><code>ggplot(who_use %&gt;% filter(iso3==&quot;USA&quot;) %&gt;% filter(method==&quot;sp&quot;) %&gt;% filter(age==&quot;65+&quot;), aes(x=year, y=value, color=gender)) +
  geom_point() +
  geom_line()</code></pre>
<pre><code>## Warning: Removed 32 rows containing missing values (`geom_point()`).</code></pre>
<pre><code>## Warning: Removed 32 rows containing missing values (`geom_line()`).</code></pre>
<p><img src="06.2.stringr_WHO_files/figure-html/unnamed-chunk-49-1.png" width="672" /></p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3,h4",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
