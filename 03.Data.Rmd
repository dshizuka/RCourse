---
title: "Module 3: Working With Data"
author: "Dai Shizuka"
date: "updated `r format(Sys.time(), '%m/%d/%y')` "
output: 
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
---

```{r setup, include=FALSE}
library(knitr)
#knitr::opts_chunk$set(out.width="3.5in")
```
##Overview
Most of you are looking to use R for data analysis, which of course requires learning how to import your data into R. This is maybe the big leap for people who are not used to programming.  

To import data into R, you will create an object that points to a dataset somewhere on your computer. R will then import that data as a **dataframe** object ([see Module 2](02.ObjectTypes.html)). 

***

##3.1 Importing Data

###3.1.1 File Formats: Use .csv (or .txt)

Many of us manage data by entering them into a spreadsheet using common software like Microsoft Excel. While there are many problems 

R can read several file formats, but the popular excel format (.xlsor .xlsx) is NOT one of them (unless you use a specialized package like `xlsx`). Instead, you will most often convert your excel sheet into one of two formats: tab-delimited files or comma-separated-values files (.csv). These are file formats that can be read by any text editor.   
If you use Excel or any other spreadsheet for data storage, you can easily convert those into one of these formats using `[Save as...]`  

In this class, I will be using .csv files for almost all data importing tasks. 

R can also handle databases (e.g., Microsoft Access) using a special package called RODBC. You can get a comprehensive tutorial [here](https://cran.r-project.org/doc/manuals/r-release/R-data.html#Relational-databases)


###3.1.3 Folder Organization & File Formats

- keep all ***raw data*** in a folder (maybe call it "data")


###3.3 "Long" vs. "Wide" format data

The most important thing to keep in mind is that your data should contain **each observation as a separate row**. For example, each subject should be a separate row. If you have repeated measurements from the same subject, each observation should be a separate row, and you should have a column that specifies which observation/trial number. 

For example, this is a "wide-format" dataframe:  

Subject|Time 1|Time 2|Time 3
----|----|----|----
A | 1.2 | 2.5 | 4.1
B | 1.6 | 2.6 | 3.8
C | 0.9 | 2.4 | 3.6

The data set could be organized in a "long-format": 

Subject|Time|Value
-------|----|-----
A|1|1.2
A|2|2.5
A|3|4.1
B|1|1.6
B|2|2.6
B|3|3.8
C|1|0.9
C|2|2.4
C|3|3.6

The order of the rows is not relevant. The key is that each observation for a given individual shows up as separate rows. 

***In general, it is preferable to keep your data in the "long-format". This is because you can 'wrangle' this data type more flexibly, and it is also more approriate for a wider array of analyses. We will address these points in the next module***


##3.2 Import .csv files

###Step 1: Download the practice data folder:  
Go to the course google drive folder for week 2 and download the entire folder called 'data' by right-clicking (or control-click) and selecting 'download'. It will compress the files into a .zip format and you can save it somewhere on your computer. Uncompress the .zip file, and you should end up with a folder named 'data'. 


###Step 2: Find out the path to your data folder and files
*Quick refresher: finding the path to a file*  
Importing data is easier if you know how to get the path to the .csv file on your computer. We covered this in [module 1 (Intro)](http://rpubs.com/rcourse998/module1-intro). 

* ***For Windows***, you can get the path name of the file or folder by right-clicking it and click "Copy as Path"
* ***For Mac (or Windows)***, you can look for the file/folder in Finder, and then drag and drop the icon into the "Go to file/function" bar at the top of the RStudio window.  

As an example, say I made folder on my **desktop** called **Rcourse** and inside that folder, I made another folder called **Week_2**. If my data folder is inside that, this would be the path: `/Users/dshizuka/Desktop/Rcourse/Week_2/data`  
In turn, the path to a file inside that folder might be:  `/Users/dshizuka/Desktop/Rcourse/Week_2/data/SampleData.csv`

###Step 3: Import the data
There are several ways to import your data in to R. Two of the methods require the use of file paths. There are two other ways you can import data without the path by manually browsing and choosing your file. However, I strongly recommend learning how to use the paths to import data. One reason is that it actually takes you longer to browse for the file. Another reason is that the script is not reproducible if you don't know which file is supposed to be imported. But at the end of the day, it's your choice how to do this. 

No matter how you import the data, the final goal is the same: assign the imported data as an object. Here, we will assign the data into an object called `dat`. (tip: I would not use "data" as an object name because `data()` is a function name). Try out each of the following methods for importing a sample data set called "SampleData_1.csv".

####Four ways to import data:

####1. Directly enter full path to file
Using the above example location for the file, you can use either of the below versions of the pathname to import the data. ***Remeber: You will have to change the path inside the lines of code here to be where the file resides in your computer.
```{r, eval=T}

dat=read.csv("data/SampleData.csv") 


```
  

  
####3. Call 'choose file' prompt. 
This will call a prompt that will let you choose the file. You can then find and choose the file you want to import. This is a convenient and quick way to import data. However, it is limiting because it takes time to click around to find the file, and more importantly, this step is not *reproducible*.
```{r, eval=FALSE}
dat=read.csv(file.choose())
```

  
####4. Using RStudio GUI
In RStudio, select `[File]`--`[Import Dataset]`--`[From CSV...]`
The first time you do this, you may be asked to install the `readr` package. **Note:** I actually do NOT recommend using this method for a variety of reasons (irreproducibility, takes time, saves the object as a special format).

--------
So let's now use method #2 to import the sample data and look at the structure of the data:
```{r, eval=F}

dat=read.csv(file="data/SampleData.csv")
str(dat)
```
```{r, eval=F, results='markup'}

dat=read.csv(file="data/SampleData.csv")
str(dat)
```
A good thing to check is whether the columns are all of the correct type (e.g., continuous variables come out as numeric, categorical variables come out as factor, etc.)

####Some important arguments inside `read.csv`
You can specify what data values should be imported as unknown data (`NA`). You do this by using the argument `na.string=`. For example, if you want R to ignore all the cell values that contain "#N/A" in your .csv file:
```{r, eval=F}
dat=read.csv(file="data/SampleData.csv", na.string="#N/A")
```

>####Importing from .txt files:
A more generic function is `read.table()`. This function allows you to read any kind of text file (including .csv files) while specifying the data is delimited. So, for example, you can use this function to import comma-separated files `dat=read.table(file.choose(), sep=",")`, or tab-delimited files `dat=read.table(file.choose(), sep="\t")`. So the `read.table()` function is more flexible in many ways.


##3.3 Some common errors when importing data

You will often have some kind of problem reading in files. One of the big roadblocks to using R is dealing with these bugs. 

Some common problems:  

* **It won't import**
    + Are you sure you saved the file as a .csv file? 
    + Is the path and file name correct?
    + Is the path and file name inside quotes?
    
* **I get a weird column that has a bunch of `NA`**
    + You probably have a column in your spreadsheet that has a value in one of the cells that you forgot about.
* **I have a weird column at the bottom of my data that is just a bunch of `NA`**
    + You probably have a cell at the bottom of your spreadsheet with "hidden spaces".
    + Fix: In excel, do a "Find and Replace" to replace blank space with some character (e.g., a *) and then go and find and erase those characters.

* **Column is supposed to be numeric but it is showing up as factors.**
    + You probably have a cell value in the column that is non-numeric, e.g., "#N/A" or 'hidden space'
    + Fix: You can specify what kind of characters should be interpreted as `NA` using the `na.string=` argument (see above).

## Exercise: Troubleshoot data import
Step 1: Import the `SampleData_w_errors.csv` file and look at its data structure:

```{r, eval=T}
errdat=read.csv("data/SampleData_w_errors.csv") 
str(errdat)
```

Step 2: Fix the spreadsheet so that you get the following:

* The column called "sex" only has "female" and "male".
* The column called "size" is numeric
* The column called "weight" is numeric
* The column called "X" is removed.

***
###3.4 Subsets and Subtotals
Many times, you will want to just look at subsets of the data: i.e., certain columns or rows that satisfy some condition.  
We already covered how to look at specific columns using either the `[]` or `$` operators. For example, to look at the sex of individuals in the sample data, we can do either:
```{r, eval=F}
#These commands will do the same thing
dat$sex
dat[,2]
dat[,"sex"]
```

In contrast, there is no equivalent of the `$` for selecting rows. But we can specify the rows we want to look at using the first element within `[]`:
```{r, eval=F}
dat[2,] #get the second row of the dataset
```

If we want to look at all rows that fulfill some criteria, we can use the `==` operator. For example, let's look at all of the data for males:
```{r, eval=T}
dat[dat$sex=="male", ]
```
In this case, R interprets this command to pick out rows in the data where the answer to `dat$sex=="male"` is TRUE.  

You can use multiple criteria to subset the data. Use the `|` to mean "or" and the `&` operator to mean "and". For example:
```{r}
dat[dat$sex=="male"|dat$weight<60,] #give me the data for rows where sex is male OR weight is less than 60. This gives you all but two records. 
```
```{r}
dat[dat$sex=="male"&dat$weight<60,] #give me the data for rows where sex is male AND weight is less than 60. This gives you just one record of the male that is less than 60g. 
```

If you want to EXCLUDE data for certain rows, you can use the `!=` operator:
```{r}
dat[dat$sex!="male",] #this will give you the records for individuals that are NOT male (i.e., females)
```

####Using the `which()` function:
Another way to subset the data is to use the `which()` function, which is extremely useful. We will be using this function a lot as we go forward.  
Basically, `which()` allows you to get the element number of a vector that fits certain criteria. For example, these are the row numbers for males in the dataset:
```{r}
which(dat$sex=="male")
```
So you can use this command to subset the data in a similar way as above:
```{r}
dat[which(dat$sex=="male"), ] #don't forget the comma!
```


You can also look at a particular variable within a particular subset. Here are two ways to do the same thing--get the body size of males.
```{r}
dat[dat$sex=="male","size"]
dat$size[dat$sex=="male"]
```

Using this, you can look at the mean size of males vs. females
```{r}
mean(dat$size[dat$sex=="male"])
mean(dat$size[dat$sex=="female"])
```

A more elegant way to do this is to use either the `tapply()` or `aggregate()` functions.
For both of these functions, the first argument is the column to apply the calculation to, second argument is the categorical variable (in list format), and the third argument is the function name for the calculation you want to apply. Try these out for calculating the mean body size by sex:
```{r}
tapply(dat$size,dat$sex,mean)
```

```{r}
aggregate(dat$size,by=list(Sex=dat$sex),mean)
```

Note that the tapply() and aggregate() uses different formats as outputs—-`tapply()` returns an array, while `aggregate()` returns a dataframe.  
You can see this better when you calculate the means while splitting up the data by two different factors, like sex and age:
```{r}
tap=tapply(dat$size,list(dat$sex,dat$age),mean)
agg=aggregate(dat$size,by=list(Sex=dat$sex, Age=dat$age),mean)
class(tap)
class(agg)
tap
agg
```
You can see that the output of `tapply` is a matrix, and the output of `aggregate()` is a dataframe. So you can use one or other function depending on what you want to do with the output of the calculation you want to do. 

For example, you can use the same set of functions to calculate the sums of sizes for each sex x age combination:
```{r}
tapply(dat$size,list(dat$sex,dat$age),sum)
aggregate(dat$size,by=list(Sex=dat$sex, Age=dat$age),sum)
```

##3.5 Linking two data sets

There are a many instances in which you have two different datasets for the same subjects. For example, I might have one dataset from capturing and measuring a bunch of individual birds. At that point, I take a blood or tissue sample from each individual and I might later use loci linked to sex chromosomes to confirm sex the individual is (many birds are monomorphic and it can be difficult to tell the sexes apart). I now have two different spreadsheets containing different pieces of information about the same subjects, and I might want to combine this information. 
	You may have done something like this in the past using “lookup functions” in excel or database software (e.g., Microsoft Access, FileMaker, etc.). Now we will learn how to do this in R. 
	Let’s start by inputting two different sets of data (one of them is the same as what we have been using so far). Remember that your directory name will be different for you:
```{r}
#assuming the working directory is already set to your sample data folder:
dat=read.csv(file="data/SampleData.csv",header=TRUE)
chromo=read.csv(file="data/sex_chromo.csv", header=TRUE)
```

We now have two dataframes—dat and sex. This second dataframe has information of sex chromosomes that we have identified for each individual using molecular methods. 
	We now use a match() function to look up which rows correspond to the same individual:

```{r}
match(dat$Indiv.ID,chromo$Indiv.ID)
```
Here, the first value indicates which row in the dataframe chromo corresponds to the first row in dat? Remember that the order of the elements within the parentheses matter. You can confirm this by looking at both dataframes. 
	You can use this to lookup the sex chromosomes for each individual in the dataframe dat. 

```{r}
sex.chromo=chromo[match(dat$Indiv.ID,chromo$Indiv.ID),"chromosomes"]
sex.chromo
```

You can append this new vector, sex.chromo, to the dataframe dat using the function cbind():
```{r}
merged.dat=cbind(dat,sex.chromo)
merged.dat
```

Ok, now that I have shown you the hard way to do this, here is the easy way, using the function merge():
```{r}
merged.dat2=merge(dat,chromo,by="Indiv.ID")
merged.dat2
```
Note that you have to make sure that the variable names are identical in both dataframes for this to work! 


Lastly, try this code to see that (in this hypothetical dataset), the sex chromosomes match up with the gender scored in the field.
```{r}
table(merged.dat2$sex,merged.dat2$chromosomes)
```

##Exercise: Import your own data

After you have run through the module, try importing your own dataset and check to make sure that all of your columns show up correctly. Then trying subsetting and calculating means of values according to different categorical variables. 