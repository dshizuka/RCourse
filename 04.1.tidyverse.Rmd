---
title: "Data Wrangling to plots with tidyverse packages"
author: "Dai Shizuka"
date: "updated `r format(Sys.time(), '%m/%d/%y')` "
output: 
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
---

## Intro to the ['tidyverse'](https://www.tidyverse.org/)

```{r, out.width="10%", echo=F}
knitr::include_graphics("images/icons/tidyr.png")
knitr::include_graphics("images/icons/dplyr.png")
knitr::include_graphics("images/icons/stringr.png")
knitr::include_graphics("images/icons/ggplot2.png")
```

Now that we have dipped our feet into plots and stats in R, I think you are getting a better sense of the fact that 'wrangling' or 'manipulating' data is one of the biggest steps to becoming proficient in R and all that it has to offer. 

For example, for any given analysis, you may have to subset data, filter out certain data that don't meet some criteria, focus in on a select set of variables of interest, calculate means, and variance for different groups, etc. etc. 

These tasks are where the packages [dplyr](https://dplyr.tidyverse.org/), [tidyr](https://tidyr.tidyverse.org/) and other packages in the [tidyverse](https://www.tidyverse.org/)--a series of packages designed for all kinds of data tasks. This also includes the popular [ggplot2](https://ggplot2.tidyverse.org/) package for graphics. 

The tidyverse packages are constructed by [Hadley Wickam](http://hadley.nz/). There are several books that cover how to use these packages, including *R for Data Science* [which is available for free as an online book](https://r4ds.had.co.nz/)

```{r, out.width="20%", echo=F}
knitr::include_graphics("images/icons/R_for_Data_Science_cover.png")
```

In this module, we'll be learning some functions from the packages **dplyr** and **tidyr**. 

We will do this by playing with data from the World Bank.

***

## Installing and loading packages we need for this module

One can install each package separately, but you can also just install all "tidyverse" packages simply by running this command:

```{r, eval=FALSE}
install.packages("tidyverse")
install.packages("wbstats")
```

Note that this simply downloads the packages onto your computer. When you are ready to use them, you will have to load the package onto the environment by running the function

You now have the package downloaded on your computer, but to actually use it, you have to load the package. We can load the entire `tidyverse` package (or, if you prefer, you can just load the `tidyr` package).

```{r}
library(wbstats)
library(tidyverse)
```

**Two important thing to notice here.** First, the message tells you what packages were actually loaded as part of the tidyverse "metapackage". You see that this includes 8 packages: ggplot2,tibble, tidyr, readr, purrr, dplyr, stringr, and forcats. Second, the message tells you that there are two functions in the `dplyr` package that conflict with existing functions: `filter()` and `lag()`. This is sometimes very important to know! This means that the `filter()` function works differently before and after loading this package.

***

><span style="color:purple">***Some things to know about getting started with 'tidyverse'***</span>
>
>**Pipe Operator (`%>%`):**
>tidyverse makes use of the pipe operator `%>%`, which allows you to carry over the output of one function to the next function. This can make series of data manipulation sequences much more efficient. 
>
>**Tibbles:**
>"tibble" is a special class of dataframe that is used in tidyverse. It is largely the same as a dataframe but it has some features (or rather, lack of features) that make for 'defensive coding'. That is, it forces you to avoid dangerous operations, such as changing variable names or types (you have to explicitly do this) or allow "partial matching".
>
>To learn more about tibbles, start [here](https://tibble.tidyverse.org/)


***

## 2. Working with *dplyr* and *tidyr*

*dplyr* is a package that helps you wrangle your data into shape to aid you in the process of visualization and analysis. 

Here is a link to the `dplyr` cheat sheet: https://github.com/rstudio/cheatsheets/blob/main/data-transformation.pdf

### 3.1 Main *dplyr* functions

* `select()` select columns by criteria
* `filter()` filter rows by criteria
* `mutate()`: add new variable using functions
* `summarise()`: calculate summary statistic for a given variable
* `arrange()`: change order of rows
* `group_by()`: run any of above function 'by group' defined using criteria
* `left_join()`, `right_join()`, `inner_join()`, `full_join()`: set of functions to help merge data tables.
* `nest_join()`: create nested datasets (advanced... I don't know how to use this yet)

<br>

I use *tidyr* mostly for reshaping data to move between "long-format" and "wide-format" data. 

Here is link to the *tidyr* cheat sheet: https://github.com/rstudio/cheatsheets/blob/master/tidyr.pdf

### 3.2 Main *tidyr* functions

* `pivot_longer()`: "lengthen" data by collapsing several columns into two.
* `pivot_wider()`: "widen" data by expanding two columns into multiple columns

***

## 3. Demonstrating the basic functions

```{r}
head(Loblolly)
```

Now let's say we want to reformat this data so that we have one row for each individual (seed), with heights at different ages across different columns. Here's how we'd do it with `pivot_wider()`. 
The minimal arguments that are required in here are: 
* `data: (self explanatory)
* `id_cols`: The column 

```{r}
pivot_wider(Loblolly, id_cols=Seed, names_from=age, values_from=height)
```

***

## 1. Population growth trends across the world

The World Bank actually makes it very easy to download a huge amount of data very easily. You could just go to the [World Bankd Open Data site](https://data.worldbank.org/) and search for data and download them in a few clicks. There are even packages such as `WDI` and `wbstats` that allow you to query and pull data from this site from within R. 

However, for the purposes of this exercise, we will deal with several datasets that are included in the packages we have loaded above.

<br>

### 1.1. `world_bank_pop`: Population data from World Bank (2000-2017)
First is the `world_bank_pop` dataset that is included in the `tidyr` package (which is part of the the tidyverse suite). Start by pulling up the help file for the dataset

```{r, eval=F}
?world_bank_pop
```

Let's take a peak at the data, which is in "tibble" format:

```{r}
world_bank_pop
```

Notice that each country is repeated across 4 rows. This is because there are actually 4 different "indicators" for each country, and so each country x indicator combination takes up a row. The rest of the columns are years, from 2000 to 2017. 

Also notice that the numbers in the column names have a backquote, or "`" around them. In R, this allows numbers to be interpreted as text (and column names have to be text). 

So, if you wanted to pull up the "2001" column, this will NOT work...
```{r, eval=F}
world_bank_pop$2001
```

...but this will work
```{r, eval=F}
world_bank_pop$`2001`
```

<br>


***
## 2. Problem 1: "Countries" that are not countries: Merging datasets with `join` functions

We are going to start by diving into the `world_bank_pop` dataset. 

Let's take a peek at the dataset again and see what we have...
```{r}
world_bank_pop
```

I want to start by looking at how many unique countries we actually have here.

```{r}
length(unique(world_bank_pop$country)) #this gives us the number of unique values in the "country" column
```

You can see that there are way more "countries" here than there are in the world. As of 2022, there are 193 countries in the United Nations, though if we add soverign states that are not recognized by UN (e.g., Taiwan, Kosovo, etc.), the list is about 206... and there are more if we include disputed territories.

The reason the World Bank data has even more than that is because some of the "countries" include "aggregates" like "Arab World" or "High-income Countries". 

Unfortunately, the `world_bank_pop` dataset does not include any variables that allow us to differentiate the countries from the aggregates! However, we can solve this problem by pulling the metadata for countries from the World Bank. We can do this by using the `wb_countries()` function from the *wbstats* package. 

Let's pull the country metadata and save it as an object called "metadata":

```{r}
metadata=wb_countries()
```

```{r}
metadata
```

```{r}
head(metadata$region)
```
So this column shows us the "Aggregates". 

```{r}
metadata %>% dplyr::filter(region != "Aggregates")
```

```{r}
metadata %>% 
  dplyr::filter(region != "Aggregates") %>%
  select(iso3c, iso2c, country, region)
```
```{r}
countries=metadata %>% 
  dplyr::filter(region != "Aggregates") %>%
  select(iso3c, iso2c, country.name=country, region, income_level) %>%
  mutate(income_level=factor(income_level, levels=c("Low income", "Lower middle income", "Upper middle income", "High income")))
```

```{r}
popdat_countries=inner_join(world_bank_pop, countries, by=c("country" = "iso3c"))
popdat_countries
```


## 3. Filtering and selecting data with `filter()` and `select()`


As mentioned above (Section 1.1), each row is a country x indicator combination, with 4 different indicators. The indicators are:

* SP.POP.GROW = population growth

* SP.POP.TOTL = total population

* SP.URB.GROW = urban population growth

* SP.URB.TOTL = total urban population

```{r}
popdat_countries %>% 
  dplyr::filter(indicator=="SP.POP.TOTL") 
```
```{r}
pop_totals=popdat_countries %>% 
  dplyr::filter(indicator=="SP.POP.TOTL") 
```


```{r}
upper_pop=pop_totals %>%
  pull(`2017`) %>% 
  quantile(., probs=0.90, na.rm=T)
upper_pop
```

```{r}
large_countries=pop_totals %>% 
  dplyr::filter(`2017` > upper_pop) %>% 
  select(country)
large_countries
```

```{r}
popgrowth_large=popdat_countries %>% 
  dplyr::filter(indicator=="SP.POP.GROW") %>%
  right_join(., large_countries, keep=FALSE) 
```

```{r}
popgrowth_large %>% select(-indicator, -country.name, -iso2c, -region, -income_level) %>% pivot_longer(!country, names_to="year", values_to="growth_rate")
```
```{r}
popgrowth_plot=popgrowth_large %>% 
  select(-indicator, -country.name, -iso2c, -region, -income_level) %>% 
  pivot_longer(!country, names_to="year", values_to="growth_rate")

ggplot(popgrowth_plot, aes(x=as.numeric(year), y=growth_rate, color=country)) +
  geom_line() +
  theme_bw()
```

```{r}
popgrowth_income=popdat_countries %>% 
  dplyr::filter(indicator=="SP.POP.GROW") %>%
  dplyr::filter(is.na(income_level)==F) %>%
  select(-indicator, -country.name, -iso2c, -region) %>% 
  pivot_longer(cols=-c(country, income_level), names_to="year", values_to="growth_rate") %>%
  group_by(income_level, year) %>%
  summarise(mean_se(growth_rate))

ggplot(popgrowth_income, aes(x=as.numeric(year), y=y, group=income_level)) +
  geom_line(aes(color=income_level)) +
  geom_ribbon(aes(ymin=ymin, ymax=ymax), alpha=0.3, fill="gray") +
  theme_bw()
```

```{r}
popdat_anova=popdat_countries %>% 
  dplyr::filter(indicator=="SP.POP.GROW") %>%
  select(country, `2017`, region, income_level) %>%
  dplyr::filter(income_level!="Not classified")

ggplot(popdat_anova, aes(x=income_level, y=`2017`)) +
  geom_boxplot(aes(color=income_level)) +
  facet_wrap(~region, nrow=3)
```
```{r}
lm.fit=lm(`2017`~region*income_level, data=popdat_anova)
summary(lm.fit)
anova(lm.fit)
```




